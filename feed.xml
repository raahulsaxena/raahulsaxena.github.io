<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://raahulsaxena.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://raahulsaxena.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-03-14T13:05:54+00:00</updated><id>https://raahulsaxena.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">NLP Interview Guide - Key Concepts and Techniques</title><link href="https://raahulsaxena.github.io/blog/2025/nlp-interview-guide/" rel="alternate" type="text/html" title="NLP Interview Guide - Key Concepts and Techniques"/><published>2025-03-14T00:00:00+00:00</published><updated>2025-03-14T00:00:00+00:00</updated><id>https://raahulsaxena.github.io/blog/2025/nlp-interview-guide</id><content type="html" xml:base="https://raahulsaxena.github.io/blog/2025/nlp-interview-guide/"><![CDATA[<h3 id="supervised-learning">Supervised Learning</h3> <p>Given a collection of labeled examples (where each example is a text <code class="language-plaintext highlighter-rouge">X</code> paired with a label <code class="language-plaintext highlighter-rouge">Y</code>), learn a mapping from <code class="language-plaintext highlighter-rouge">X</code> to <code class="language-plaintext highlighter-rouge">Y</code>.</p> <h3 id="self-supervised-learning">Self-Supervised Learning</h3> <p>Given a collection of <em>just text</em>, without extra labels, <strong>create labels out of the text</strong> and use them for <em>pretraining</em> a model that has some general understanding of human language.</p> <ul> <li><strong>Language Modeling</strong>: Given the beginning of a sentence or document, predict the next word.</li> <li><strong>Masked Language Modeling</strong>: Given an entire document with some words or spans masked out, predict the missing words.</li> </ul> <h3 id="in-context-learning">In-context Learning</h3> <p>First pretrain a self-supervised model, and then prompt it in natural language to solve a particular task without any further understanding.</p> <p>Example: pretrain a LLM on billions of words, and then feed in *what is the sentiment of this sentence: <insert sentence="">*</insert></p> <ul> <li>Checkout <a href="http://api.together.xyz"><strong>api.together.xyz</strong></a> !</li> </ul> <h2 id="n-gram-language-models">N-gram Language Models</h2> <p>Let’s say we wanted to train a supervised model on sentiment analysis. In the past, we would have trained a supervised model on labeled examples (text/score pairs).</p> <div class="row mt-3 justify-content-center"> <div class="col-sm-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/nlp-guide/n-gram-1-480.webp 480w,/assets/img/nlp-guide/n-gram-1-800.webp 800w,/assets/img/nlp-guide/n-gram-1-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/nlp-guide/n-gram-1.png" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> N-gram Language Model </div> <p>Nowadays, we take advantage of <em>transfer learning</em>:</p> <div class="row mt-3 justify-content-center"> <div class="col-sm-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/nlp-guide/n-gram-2-480.webp 480w,/assets/img/nlp-guide/n-gram-2-800.webp 800w,/assets/img/nlp-guide/n-gram-2-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/nlp-guide/n-gram-2.png" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Transfer Learning </div> <p>For n-gram models discussion, we focus on language modeling which form the core of <strong><em>Step 1: self-supervised pretraining.</em></strong></p> <h3 id="language-models-assign-a-probability-to-a-piece-of-text">Language Models Assign a Probability to a Piece of Text</h3> <ul> <li><strong>Translation</strong>: Picking the most likely translation from a list of candidates. <ul> <li>P(i flew to the movies) «« P(i went to the movies)</li> </ul> </li> <li><strong>Speech Recognition</strong>: <ul> <li>P(i saw a van) »» P(eyes awe of an)</li> </ul> </li> </ul> <p>Language models allow us to assign this probability to the words. Example: in search bars.</p> <h3 id="probabilistic-language-modeling">Probabilistic Language Modeling</h3> <ul> <li><strong>Goal</strong>: Compute the probability of a sentence or sequence of words.</li> </ul> <h4 id="the-chain-rule">The Chain Rule</h4> <p><strong>Conditional Probability</strong>:</p> \[P(B | A) = \frac{P(A, B)}{P(A)}\] <p>Rewriting:</p> \[P(A, B) = P(A) P(B | A)\] <p>The chain rule in general:</p> \[P(x_1, x_2, x_3, ..., x_n) = P(x_1) P(x_2 | x_1) P(x_3 | x_1, x_2) ... P(x_n | x_1, ..., x_{n-1})\] <p>Chain Rule Applied to Compute Joint Probability of Words in a Sentence</p> \[P(w_1 w_2 \dots w_n) = \prod_{i} P(w_i | w_1 w_2 \dots w_{i-1})\] <p>Example Calculation:</p> <p>For the sentence <strong>“its water is so transparent”</strong>:</p> \[P(\text{"its water is so transparent"}) = P(\text{its}) \times P(\text{water} | \text{its}) \times P(\text{is} | \text{its water})\] \[\times P(\text{so} | \text{its water is}) \times P(\text{transparent} | \text{its water is so})\] <ul> <li><strong>Unigram Model</strong>: Calculating the probability of “its” without any context. Frequency of <em>its</em> in the given corpus.</li> </ul> <p>Estimating these probabilities:</p> \[P(\text{the} | \text{its water is so transparent that}) = \frac{Count(\text{its water is so transparent that the})}{Count(\text{its water is so transparent that})}\] <ul> <li>This suffers from <strong>sparsity</strong> because the phrase “its water is so transparent that” might occur only a handful of times in the corpus.</li> <li>Also, we aren’t sharing information across semantically similar prefixes in this approach. All prefixes are treated independently, which is inefficient.</li> <li>Therefore, we use <strong>Markov Assumption</strong>: It will not consider words beyond a fixed window size (context length).</li> </ul> \[P(\text{the} | \text{its water is so transparent that}) \approx P(\text{the} | \text{transparent that})\] <ul> <li>Checkout <strong>infini-gram</strong> paper.</li> </ul> <h3 id="one-hot-vectors">One Hot Vectors</h3> <ul> <li>N-gram models rely on the “bag-of-words” assumption.</li> <li>Represent each word/n-gram as a vector of zeros with a single 1 identifying its index.</li> </ul> <div class="row mt-3 justify-content-center"> <div class="col-sm-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/nlp-guide/one-hot-1-480.webp 480w,/assets/img/nlp-guide/one-hot-1-800.webp 800w,/assets/img/nlp-guide/one-hot-1-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/nlp-guide/one-hot-1.png" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> One Hot Vector </div> <ul> <li>All words are equally similar, even though “movies” and “film” are semantically similar. There is no information sharing between different words. All words are orthogonal.</li> <li>We ideally want a representation space in which words, phrases, sentences, etc. that are semantically similar have similar representations.</li> </ul> <h3 id="notion-of-perplexity">Notion of Perplexity</h3> <ul> <li><strong>Lower perplexity = better model</strong>.</li> <li>Perplexity is the <em>exponentiated token-level negative log-likelihood</em>.</li> <li>Given a prefix, how many next words are reasonable predictions given that prefix.</li> </ul> \[\text{Perplexity}(\mathcal{W}) = e^{ - \frac{1}{N} \sum_{i=1}^{N} \log P(w_i | w_1, w_2, ..., w_{i-1}) }\] <table> <thead> <tr> <th>N-gram Order</th> <th>Unigram</th> <th>Bigram</th> <th>Trigram</th> </tr> </thead> <tbody> <tr> <td>Perplexity</td> <td>962</td> <td>170</td> <td>109</td> </tr> </tbody> </table> <h2 id="neural-language-models">Neural Language Models</h2> <div class="row mt-3 justify-content-center"> <div class="col-sm-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/nlp-guide/nlm-1-480.webp 480w,/assets/img/nlp-guide/nlm-1-800.webp 800w,/assets/img/nlp-guide/nlm-1-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/nlp-guide/nlm-1.png" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Neural Language Model </div> <h3 id="words-as-basic-building-blocks">Words as Basic Building Blocks</h3> <ul> <li>Represent words with low-dimensional vectors called embeddings.</li> </ul> <div class="row mt-3 justify-content-center"> <div class="col-sm-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/nlp-guide/nlm-2-480.webp 480w,/assets/img/nlp-guide/nlm-2-800.webp 800w,/assets/img/nlp-guide/nlm-2-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/nlp-guide/nlm-2.png" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Words as Basic Building Blocks </div> <ul> <li>There is a loss of interpretation with these numbers. [Research field of explainability]</li> <li>The word embeddings start completely randomly.</li> <li>Neural networks compose word embeddings into vectors for phrases, sentences, and documents. It uses word embeddings to find representations for phrases and sentences.</li> </ul> <div class="row mt-3 justify-content-center"> <div class="col-sm-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/nlp-guide/nlm-3-480.webp 480w,/assets/img/nlp-guide/nlm-3-800.webp 800w,/assets/img/nlp-guide/nlm-3-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/nlp-guide/nlm-3.png" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <ul> <li>Predict the next word from composed prefix representation.</li> </ul> <div class="row mt-3 justify-content-center"> <div class="col-sm-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/nlp-guide/nlm-4-480.webp 480w,/assets/img/nlp-guide/nlm-4-800.webp 800w,/assets/img/nlp-guide/nlm-4-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/nlp-guide/nlm-4.png" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> </div> <h3 id="linear-layer-feedforward-layer-on-the-prefix-vector-representation">Linear Layer (Feedforward Layer) on the Prefix Vector Representation</h3> <div class="row mt-3 justify-content-center"> <div class="col-sm-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/nlp-guide/ll-1-480.webp 480w,/assets/img/nlp-guide/ll-1-800.webp 800w,/assets/img/nlp-guide/ll-1-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/nlp-guide/ll-1.png" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Feed-forward Layer </div> <p>How to go from vector representation (Wx) to a probability distribution of the next word?</p> <ul> <li><strong>Softmax Layer</strong>: Converts a vector representation into a probability distribution over the entire vocabulary.</li> </ul> <div class="row mt-3 justify-content-center"> <div class="col-sm-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/nlp-guide/softmax-2-480.webp 480w,/assets/img/nlp-guide/softmax-2-800.webp 800w,/assets/img/nlp-guide/softmax-2-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/nlp-guide/softmax-2.png" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Softmax </div> <h3 id="different-types-of-composition-functions">Different Types of Composition Functions</h3> <p><em>Input</em>: sequence of word embeddings corresponding to the tokens of a given prefix.</p> <p><em>Output</em>: single vector.</p> <ul> <li>Element-wise functions (e.g., just sum up all the embeddings)</li> <li>Concatenation</li> <li>Feed-forward neural networks</li> <li>RNNs</li> <li>Transformers</li> </ul> <h3 id="a-fixed-window-neural-language-model">A Fixed Window Neural Language Model</h3> <div class="row mt-3 justify-content-center"> <div class="col-sm-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/nlp-guide/fixed-window-1-480.webp 480w,/assets/img/nlp-guide/fixed-window-1-800.webp 800w,/assets/img/nlp-guide/fixed-window-1-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/nlp-guide/fixed-window-1.png" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Fixed Window Neural Language Model </div> <ul> <li><em>ReLU</em> non-linearity = max(0, x). Others include <em>tanh</em> and <em>sigmoid</em>.</li> <li><em>f</em> in the above figure is a non-linear function. We want to model non-linear relationships, and therefore there is a need for non-linear functions.</li> </ul> <h3 id="how-does-this-compare-to-normal-n-gram-model">How Does This Compare to Normal N-gram Model?</h3> <p><strong>Improvements</strong>:</p> <ul> <li>No sparsity problem.</li> <li>Model size is O(n), not O(exp(n)).</li> </ul> <p><strong>Remaining Problems</strong>:</p> <ul> <li>Fixed window size is very small.</li> <li>Enlarging window size enlarges <strong><em>W</em></strong>.</li> <li>Window can never be large enough!</li> <li>Each Ci uses different rows of <strong><em>W</em></strong>. We don’t share weights across the window.</li> </ul> <p>These remaining problems are addressed by <strong>Recurrent Neural Networks</strong>.</p> <h2 id="recurrent-neural-networks">Recurrent Neural Networks</h2> <p>It is <strong>sequential</strong> and does the calculation from left to right [words of prefix].</p> <ul> <li>It addresses the problem of not sharing the weights across the window.</li> <li>It also takes care of the Markov assumption. Theoretically, there is no limit to <code class="language-plaintext highlighter-rouge">t</code> in the RNN equation. We can keep on calculating <code class="language-plaintext highlighter-rouge">h(t)</code>.</li> </ul> <div class="row mt-3 justify-content-center"> <div class="col-sm-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/nlp-guide/rnn-1-480.webp 480w,/assets/img/nlp-guide/rnn-1-800.webp 800w,/assets/img/nlp-guide/rnn-1-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/nlp-guide/rnn-1.png" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Recurrent Neural Network </div> <h3 id="rnn-advantages">RNN Advantages:</h3> <ul> <li>Can process any length input.</li> <li>Model size doesn’t increase for longer input.</li> <li>No limit on the size of the window (theoretically). Can use information from many steps back.</li> <li>Weights are shared across timestamps → representations are shared.</li> </ul> <h3 id="rnn-disadvantages">RNN Disadvantages:</h3> <ul> <li>Recurrent computation is slow.</li> <li>In practice, difficult to access information from many steps back.</li> </ul> <h2 id="neural-language-models-backpropagation">Neural Language Models [Backpropagation]</h2> <h3 id="training-neural-language-models">Training Neural Language Models</h3> <ul> <li>Last time we talked about forward propagation.</li> <li>How can we make NLMs make good predictions?</li> <li>NLMs contain parameters (e.g., <code class="language-plaintext highlighter-rouge">W1</code>, <code class="language-plaintext highlighter-rouge">W2</code>, <code class="language-plaintext highlighter-rouge">c1</code>, <code class="language-plaintext highlighter-rouge">c2</code>…) <ul> <li>These parameters are randomly initialized.</li> <li> <table> <tbody> <tr> <td>Thus, $P(w_1 w_2 \dots w_n) = \prod_{i} P(w_i</td> <td>w_1 w_2 \dots w_{i-1})$ is also randomized initially.</td> </tr> </tbody> </table> </li> </ul> </li> <li>By training the NLM, we adjust its parameters to maximize the likelihood of the training data.</li> </ul> <p><strong>Recap of Forward Propagation</strong></p> <div class="row mt-3 justify-content-center"> <div class="col-sm-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/nlp-guide/forward-1-480.webp 480w,/assets/img/nlp-guide/forward-1-800.webp 800w,/assets/img/nlp-guide/forward-1-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/nlp-guide/forward-1.png" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Forward Propagation </div> <h3 id="steps-to-train-a-neural-language-model">Steps to Train a Neural Language Model</h3> <ol> <li>Define a loss function <strong>L(ϴ)</strong>, where ϴ refers to all the parameters of the model. <ul> <li>This tells us how bad the model is at predicting the next word.</li> <li>Loss function is required to be smooth and differentiable.</li> </ul> </li> <li>Given the loss function <strong>L(ϴ)</strong>, we compute the gradient of L with respect to ϴ. <ul> <li>The gradient provides us the direction of steepest ascent of the loss function.</li> <li>Step in negative gradient will minimize the loss function. <strong>That’s the goal</strong>!</li> <li>Gradient is same dimensionality as ϴ.</li> </ul> </li> <li>Given the gradient <code class="language-plaintext highlighter-rouge">dL/dϴ</code>, we take a step in the direction of the negative gradient.</li> </ol> \[\theta_{\text{new}} = \theta_{\text{old}} - \eta \cdot \nabla_{\theta} L\] <p>Where:</p> <ul> <li>$\theta$ represents the model parameters</li> <li>$\eta$ is the learning rate</li> <li>$\nabla_{\theta} L$ is the gradient of the loss function with respect to $\theta$</li> </ul> <p><strong>Optimizers</strong>:</p> <ul> <li>Gradient Descent parameter: The one shown above is SGD (stochastic gradient descent).</li> <li>Other optimizers include Adam, Sophia (LLMs).</li> </ul> <p><strong>Hyperparameters of Gradient Descent</strong>:</p> <ul> <li>Learning rate</li> <li>Batch size</li> </ul> <p><strong>Loss Function</strong>:</p> <ul> <li>Loss function: Cross-entropy loss, negative log-likelihood of the next word from the training data given the prefix.</li> </ul>]]></content><author><name></name></author><category term="Natural Language Processing"/><category term="Machine Learning"/><category term="NLP"/><category term="Machine Learning"/><category term="Algorithms"/><summary type="html"><![CDATA[A comprehensive guide to understanding core NLP concepts and techniques, including supervised learning, self-supervised learning, language models, and more.]]></summary></entry><entry><title type="html">Mastering Knapsack The Dynamic Programming Patterns You Need to Know</title><link href="https://raahulsaxena.github.io/blog/2025/knapsack-like/" rel="alternate" type="text/html" title="Mastering Knapsack The Dynamic Programming Patterns You Need to Know"/><published>2025-03-13T15:09:00+00:00</published><updated>2025-03-13T15:09:00+00:00</updated><id>https://raahulsaxena.github.io/blog/2025/knapsack-like</id><content type="html" xml:base="https://raahulsaxena.github.io/blog/2025/knapsack-like/"><![CDATA[<p>This pattern has two sub-patterns namely, 0-1 Knapsack and Unbounded Knapsack. Together, the type of problems that match these patterns are called “Knapsack-like” problems.</p> <h2 id="pattern-0-1-knapsack">Pattern: 0-1 Knapsack</h2> <h3 id="overview">Overview:</h3> <p>The 0/1 Knapsack pattern is one of the most fundamental dynamic programming problems. In this pattern, you are given a set of items, each with a weight and a value, and a knapsack with a limited capacity. The goal is to maximize the value of the items in the knapsack without exceeding its capacity. The “0/1” refers to the fact that each item can either be included in the knapsack (1) or excluded (0).</p> <p>This pattern can be extended to problems where you need to make decisions under constraints, such as selecting courses with a certain number of credit hours, choosing projects with a fixed number of resources, or dividing a set of numbers into subsets with equal sums.</p> <h3 id="key-concepts">Key Concepts:</h3> <ul> <li><strong>Decision Making:</strong> At each step, you must decide whether to include or exclude an item (or option) based on the problem’s constraints.</li> <li><strong>State Representation:</strong> The state is typically represented by the remaining capacity of the knapsack and the items under consideration.</li> <li><strong>Recursive Relation:</strong> The problem can be broken down recursively by considering two scenarios: including the current item or excluding it.</li> </ul> <h3 id="code-example-partition-equal-subset-sum">Code Example: Partition Equal Subset Sum</h3> <p>Let’s explore the “Partition Equal Subset Sum” problem, where we need to determine if a given set of numbers can be partitioned into two subsets with equal sums.</p> <p><strong>Problem Statement:</strong></p> <p>Given a non-empty array <code class="language-plaintext highlighter-rouge">nums</code> containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p> <p><strong>Code Implementation:</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">bool</span> <span class="nf">canPartition</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">totalSum</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
    
    <span class="c1">// If the total sum is odd, it's impossible to partition it into two equal subsets</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">totalSum</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">totalSum</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">target</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">));</span>
    
    <span class="c1">// Initialize DP table: we can always have a sum of 0 with an empty subset</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// Fill the DP table</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">||</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]];</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">target</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">canPartition</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Can partition into equal subsets."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Cannot partition into equal subsets."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="explanation">Explanation:</h3> <ol> <li><strong>State Representation:</strong> <ul> <li>The DP table <code class="language-plaintext highlighter-rouge">dp[i][j]</code> represents whether it is possible to achieve a sum <code class="language-plaintext highlighter-rouge">j</code> using the first <code class="language-plaintext highlighter-rouge">i</code> items.</li> </ul> </li> <li><strong>Base Case:</strong> <ul> <li>We can always achieve a sum of <code class="language-plaintext highlighter-rouge">0</code> by excluding all items, hence <code class="language-plaintext highlighter-rouge">dp[i][0] = true</code> for all <code class="language-plaintext highlighter-rouge">i</code>.</li> </ul> </li> <li><strong>Recursive Relation:</strong> <ul> <li>For each item <code class="language-plaintext highlighter-rouge">i</code> and target sum <code class="language-plaintext highlighter-rouge">j</code>, we have two choices: <ul> <li><strong>Exclude the current item:</strong> In this case, <code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i-1][j]</code>.</li> <li><strong>Include the current item:</strong> Check if the remaining sum <code class="language-plaintext highlighter-rouge">j - nums[i-1]</code> can be achieved with the previous items, i.e., <code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i-1][j-nums[i-1]]</code>.</li> </ul> </li> </ul> </li> <li><strong>Final Answer:</strong> <ul> <li>The final answer is stored in <code class="language-plaintext highlighter-rouge">dp[n][target]</code>, where <code class="language-plaintext highlighter-rouge">n</code> is the number of items and <code class="language-plaintext highlighter-rouge">target</code> is half of the total sum of the array.</li> </ul> </li> </ol> <h3 id="problems">Problems:</h3> <ul> <li><a href="https://leetcode.com/problems/partition-equal-subset-sum/">Partition Equal Subset Sum</a></li> <li><a href="https://leetcode.com/problems/last-stone-weight-ii/">Last Stone Weight II</a></li> <li><a href="https://leetcode.com/problems/target-sum/">Target Sum</a></li> </ul> <h2 id="pattern-2-unbounded-knapsack">Pattern 2: Unbounded Knapsack</h2> <h3 id="overview-1">Overview:</h3> <p>The Unbounded Knapsack pattern is a variation of the 0/1 Knapsack problem where you are allowed to include an unlimited number of instances of each item. This pattern is applicable in scenarios where repetition is allowed, such as cutting rods into pieces, making change with coins, or maximizing profit with unlimited resources.</p> <h3 id="key-concepts-1">Key Concepts:</h3> <ul> <li><strong>Decision Making:</strong> At each step, you must decide whether to include an item in the knapsack, and unlike the 0/1 Knapsack, you can include the same item multiple times.</li> <li><strong>State Representation:</strong> The state is represented by the current capacity of the knapsack and the items considered so far.</li> <li><strong>Recursive Relation:</strong> The recursive relationship accounts for the possibility of reusing the same item multiple times.</li> </ul> <h3 id="code-example-coin-change">Code Example: Coin Change</h3> <p>Let’s explore the “Coin Change” problem, where you need to determine the minimum number of coins needed to make up a given amount.</p> <p><strong>Problem Statement:</strong></p> <p>Given an array of integers <code class="language-plaintext highlighter-rouge">coins</code> representing different denominations of coins and an integer <code class="language-plaintext highlighter-rouge">amount</code> representing a total amount of money, return the fewest number of coins needed to make up that amount. If that amount cannot be made up by any combination of the coins, return <code class="language-plaintext highlighter-rouge">-1</code>.</p> <p><strong>Code Implementation:</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;climits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">coinChange</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">coins</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Base case: To make 0 amount, 0 coins are needed</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">coin</span> <span class="o">:</span> <span class="n">coins</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">coin</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">coin</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">coin</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">coins</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">coinChange</span><span class="p">(</span><span class="n">coins</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Minimum coins required: "</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Amount cannot be made with given coins."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div> <h3 id="explanation-1">Explanation:</h3> <ol> <li><strong>State Representation:</strong> <ul> <li>The DP array <code class="language-plaintext highlighter-rouge">dp[i]</code> represents the minimum number of coins needed to make the amount <code class="language-plaintext highlighter-rouge">i</code>.</li> </ul> </li> <li><strong>Base Case:</strong> <ul> <li>To make the amount <code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">0</code> coins are needed, so <code class="language-plaintext highlighter-rouge">dp[0] = 0</code>.</li> </ul> </li> <li><strong>Recursive Relation:</strong> <ul> <li>For each amount <code class="language-plaintext highlighter-rouge">i</code>, we iterate over all the coins. If <code class="language-plaintext highlighter-rouge">i - coin &gt;= 0</code>, then <code class="language-plaintext highlighter-rouge">dp[i]</code> can be updated as <code class="language-plaintext highlighter-rouge">dp[i] = std::min(dp[i], dp[i - coin] + 1)</code>. This checks if the current coin can contribute to the solution and updates the minimum coins needed.</li> </ul> </li> <li><strong>Final Answer:</strong> <ul> <li>The final answer is stored in <code class="language-plaintext highlighter-rouge">dp[amount]</code>. If it’s still <code class="language-plaintext highlighter-rouge">INT_MAX</code>, then the amount cannot be made with the given coins, so return <code class="language-plaintext highlighter-rouge">-1</code>.</li> </ul> </li> </ol> <h3 id="problems-1">Problems:</h3> <ul> <li><a href="https://leetcode.com/problems/coin-change/">Coin Change</a></li> <li><a href="https://www.geeksforgeeks.org/cutting-a-rod-dp-13/">Rod Cutting</a></li> <li><a href="https://www.geeksforgeeks.org/unbounded-knapsack-repetition-items-allowed/">Unbounded Knapsack</a></li> </ul>]]></content><author><name></name></author><category term="problem-solving"/><category term="leetcode"/><summary type="html"><![CDATA[Knapsack problems are a cornerstone of dynamic programming, appearing in countless algorithmic challenges. In this guide, we break down the 0-1 Knapsack and Unbounded Knapsack patterns]]></summary></entry><entry><title type="html">Branching Out A Deep Dive into Binary Trees</title><link href="https://raahulsaxena.github.io/blog/2024/binary-tree/" rel="alternate" type="text/html" title="Branching Out A Deep Dive into Binary Trees"/><published>2024-09-13T15:09:00+00:00</published><updated>2024-09-13T15:09:00+00:00</updated><id>https://raahulsaxena.github.io/blog/2024/binary-tree</id><content type="html" xml:base="https://raahulsaxena.github.io/blog/2024/binary-tree/"><![CDATA[<p>Binary trees are a fundamental data structure in computer science, often used in various applications ranging from databases to operating systems. Understanding the different types of problems and patterns associated with binary trees is essential for anyone looking to master data structures and algorithms. In this guide, we will explore key binary tree problem patterns and provide examples for each.</p> <h3 id="prerequisites">Prerequisites</h3> <p>Before diving into binary tree problems, it’s important to have a solid grasp of the following concepts:</p> <ul> <li><strong>Recursion</strong></li> <li><strong>Stack and Queue data structures</strong></li> <li><strong>Tree Traversals (Inorder, Preorder, Postorder)</strong></li> </ul> <h2 id="important-binary-tree-patterns">Important Binary Tree Patterns</h2> <h2 id="pattern-1-tree-traversals">Pattern 1: Tree Traversals</h2> <h3 id="overview">Overview</h3> <p>Tree traversals are fundamental operations in binary trees, where each node in the tree is visited in a systematic way. The most common traversals are Inorder, Preorder, and Postorder.</p> <p><strong>Problems:</strong></p> <ul> <li><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/">Inorder Traversal</a> (Iterative and Recursive)</li> <li><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/">Preorder Traversal</a> (Iterative and Recursive)</li> <li><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/">Postorder Traversal</a> (Iterative and Recursive)</li> <li><a href="https://leetcode.com/problems/recover-binary-search-tree/">Morris Inorder Traversal</a></li> <li><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/">Morris Preorder Traversal</a></li> </ul> <p><strong>Code Example (Inorder Traversal - Iterative):</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Iterative Inorder Traversal in C++</span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">stack</span><span class="p">;</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="pattern-2-level-order-traversal">Pattern 2: Level Order Traversal</h2> <p><strong>Overview:</strong> Level Order Traversal, also known as Breadth-First Search (BFS) for trees, involves visiting all the nodes level by level, from left to right. It’s commonly used to solve problems where you need to examine nodes on the same level of the tree.</p> <p><strong>Key Points:</strong></p> <ul> <li>Use a queue to keep track of nodes at the current level.</li> <li>Process nodes level by level, adding their children to the queue.</li> <li>This approach is particularly useful for problems that involve hierarchical data.</li> </ul> <p><strong>Problems:</strong></p> <ul> <li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/">Level Order Traversal</a></li> <li><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/">Zigzag Level Order Traversal</a></li> <li><a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/">Vertical Order Traversal</a></li> <li><a href="https://leetcode.com/problems/binary-tree-right-side-view/description/">Binary Tree Right Side View</a></li> </ul> <p><strong>Code Example (Level Order Traversal):</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Level Order Traversal in C++</span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">levelOrder</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">level</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">level</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="explanation">Explanation</h3> <p>•A queue is used to store nodes of the tree. •The size of the queue at each level is captured to determine the number of nodes on that level. •Nodes are processed one level at a time, and their children are added to the queue for the next level.</p> <h2 id="pattern-3-views-of-binary-tree">Pattern 3: Views of Binary Tree</h2> <p><strong>Overview:</strong> The “views” of a binary tree refer to the nodes that are visible when the tree is viewed from different perspectives: top, left, right, and boundary views. These problems require traversing the tree in a way that simulates how the tree would look from a specific direction.</p> <p><strong>Key Points:</strong></p> <ul> <li><strong>Top View:</strong> Nodes visible when the tree is viewed from the top.</li> <li><strong>Left View:</strong> Nodes visible when the tree is viewed from the left side.</li> <li><strong>Right View:</strong> Nodes visible when the tree is viewed from the right side.</li> <li><strong>Boundary View:</strong> Combination of the left boundary, leaves, and right boundary.</li> </ul> <p><strong>Problems:</strong></p> <ul> <li><a href="https://www.geeksforgeeks.org/problems/top-view-of-binary-tree/1">Top View of Binary Tree</a></li> <li><a href="https://www.geeksforgeeks.org/problems/left-view-of-binary-tree/1">Left View of Binary Tree</a></li> <li><a href="https://leetcode.com/problems/binary-tree-right-side-view/description/">Binary Tree Right Side View</a></li> <li><a href="https://leetcode.com/problems/boundary-of-binary-tree/description/">Boundary of a Binary Tree</a></li> </ul> <p><strong>Code Example (Right Side View):</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Right Side View of Binary Tree in C++</span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rightSideView</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span> <span class="c1">// Last node on this level</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="explanation-1">Explanation:</h3> <p>• A queue is used for level-order traversal. • For the right side view, the last node of each level is added to the result. • Similar approaches can be adapted for top, left, and boundary views, with modifications to focus on the specific nodes that should be visible.</p> <h2 id="pattern-4-binary-tree-properties-and-depth-calculations">Pattern 4: Binary Tree Properties and Depth Calculations</h2> <p><strong>Overview:</strong> Binary tree properties and depth calculations involve determining various metrics related to the structure of a tree, such as its depth, height, diameter, and width. These problems often require recursive approaches to traverse the tree and calculate the desired properties.</p> <p><strong>Key Points:</strong></p> <ul> <li><strong>Maximum/Minimum Depth:</strong> The number of nodes along the longest/shortest path from the root node down to the farthest/nearest leaf node.</li> <li><strong>Balanced Binary Tree:</strong> A binary tree is balanced if the depth of the two subtrees of every node never differs by more than one.</li> <li><strong>Diameter:</strong> The length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</li> <li><strong>Width:</strong> The maximum number of nodes at any level of the binary tree.</li> </ul> <p><strong>Problems:</strong></p> <ul> <li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/">Maximum Depth of Binary Tree</a></li> <li><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/">Minimum Depth of Binary Tree</a></li> <li><a href="https://leetcode.com/problems/balanced-binary-tree/">Balanced Binary Tree</a></li> <li><a href="https://leetcode.com/problems/diameter-of-binary-tree/description/">Diameter of Binary Tree</a></li> <li><a href="https://leetcode.com/problems/maximum-width-of-binary-tree/description/">Maximum Width of Binary Tree</a></li> <li><a href="https://leetcode.com/problems/invert-binary-tree/description/">Invert Binary Tree</a></li> <li><a href="https://leetcode.com/problems/find-leaves-of-binary-tree/description/">Find Leaves of Binary Tree</a></li> <li><a href="https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/">Maximum Level Sum of a Binary Tree</a></li> <li><a href="https://leetcode.com/problems/deepest-leaves-sum/description/">Deepest Leaves Sum</a></li> </ul> <p><strong>Code Example (Maximum Depth of Binary Tree):</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Maximum Depth of Binary Tree in C++</span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">leftDepth</span> <span class="o">=</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">rightDepth</span> <span class="o">=</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">leftDepth</span><span class="p">,</span> <span class="n">rightDepth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="explanation-2">Explanation</h3> <p>•Maximum Depth: This is calculated by recursively finding the depth of the left and right subtrees and returning the maximum of the two, plus one for the current node. •Balanced Binary Tree: For checking if a tree is balanced, you can calculate the depth of each subtree and ensure that the difference is no more than one at every node. •Diameter: To find the diameter, calculate the depth of left and right subtrees for each node and track the maximum sum of these depths across all nodes. •Width: Use level order traversal to count the number of nodes at each level and keep track of the maximum.</p> <h2 id="pattern-5-lowest-common-ancestor-lca">Pattern 5: Lowest Common Ancestor (LCA)</h2> <p><strong>Overview:</strong> The Lowest Common Ancestor (LCA) of two nodes in a binary tree is the deepest node that is an ancestor of both nodes. This concept is widely used in problems involving relationships between nodes in a tree, such as finding common ancestors or determining hierarchical structures.</p> <p><strong>Key Points:</strong></p> <ul> <li><strong>LCA in Binary Tree:</strong> In a general binary tree, the LCA is found by recursively traversing the tree. If a node matches one of the target nodes, it’s returned as a potential LCA.</li> <li><strong>LCA in Binary Search Tree (BST):</strong> In a BST, the LCA can be found more efficiently by leveraging the properties of the BST. The search is guided by comparing node values.</li> <li><strong>Applications:</strong> LCA problems are often used in scenarios involving hierarchical data, such as organizational charts, genealogical trees, and file systems.</li> </ul> <p><strong>Problems:</strong></p> <ul> <li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">Lowest Common Ancestor of a Binary Tree</a></li> <li><a href="https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/description/">Maximum Difference Between Node and Ancestor</a></li> <li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/description/">Lowest Common Ancestor of Deepest Leaves</a></li> <li><a href="https://leetcode.com/problems/kth-ancestor-of-a-tree-node/description/">Kth Ancestor of a Tree Node</a></li> </ul> <p><strong>Code Example (LCA in a Binary Tree):</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Lowest Common Ancestor in a Binary Tree in C++</span>
<span class="n">TreeNode</span><span class="o">*</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="n">root</span> <span class="o">==</span> <span class="n">p</span> <span class="o">||</span> <span class="n">root</span> <span class="o">==</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">left</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">right</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">?</span> <span class="n">left</span> <span class="o">:</span> <span class="n">right</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="explanation-3">Explanation</h3> <p>•Recursive Approach: The LCA is found by recursively searching the left and right subtrees. If both the left and right subtree contain one of the nodes, then the current node is the LCA. If only one subtree contains both nodes, that subtree contains the LCA. •Edge Cases: If either p or q is the root, then the root itself is the LCA. If both nodes are found in the same subtree, the LCA is in that subtree.</p> <h2 id="pattern-6-rooted-path---root-to-leaf">Pattern 6: Rooted Path - Root to Leaf</h2> <p><strong>Overview:</strong> Rooted path problems involve finding and analyzing paths from the root node to leaf nodes in a binary tree. These problems often require calculating sums, checking for specific properties along the path, or generating all possible paths from the root to leaves.</p> <p><strong>Key Points:</strong></p> <ul> <li><strong>Root to Leaf Paths:</strong> These problems generally require traversing the tree to collect or analyze the data from the root to each leaf node.</li> <li><strong>Path Sum Calculations:</strong> Many problems involve calculating the sum of node values along a root-to-leaf path and checking against a target sum.</li> <li><strong>Backtracking:</strong> Often, backtracking is used to explore all possible paths from the root to the leaf nodes, making sure to revert changes to the path as you backtrack up the tree.</li> </ul> <p><strong>Problems:</strong></p> <ul> <li><a href="https://leetcode.com/problems/binary-tree-paths/description/">Binary Tree Paths</a></li> <li><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/description/">Sum Root to Leaf Numbers</a></li> <li><a href="https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/description/">Pseudo-Palindromic Paths in a Binary Tree</a></li> <li><a href="https://leetcode.com/problems/path-sum-iii/description/">Path Sum III</a></li> </ul> <p><strong>Code Example (Binary Tree Paths):</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Binary Tree Paths in C++</span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">findPaths</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">paths</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    
    <span class="n">path</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">paths</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span> <span class="c1">// Leaf node</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">path</span> <span class="o">+=</span> <span class="s">"-&gt;"</span><span class="p">;</span>
        <span class="n">findPaths</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">paths</span><span class="p">);</span>
        <span class="n">findPaths</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">paths</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">binaryTreePaths</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">paths</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="n">findPaths</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="n">paths</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">paths</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="explanation-4">Explanation</h3> <p>•Recursive Traversal: The tree is traversed recursively, constructing a path string as you go from the root to each leaf node. •Leaf Nodes: When a leaf node is reached (a node with no children), the constructed path is added to the list of paths. •Backtracking: After exploring one path, the function backtracks to explore alternative paths from the root to other leaf nodes.</p> <h3 id="applications">Applications</h3> <p>•Path Generation: Generating all paths from the root to leaf nodes in hierarchical structures like file systems or organizational charts. •Sum Calculations: Problems that involve finding paths that sum up to a specific value, commonly used in financial or decision-making models.</p> <h2 id="pattern-7-tree-construction-and-conversion">Pattern 7: Tree Construction and Conversion</h2> <p><strong>Overview:</strong> Tree construction and conversion problems involve creating a binary tree from given traversal orders or converting a tree into a different structure. These problems often require a deep understanding of tree properties and traversal methods.</p> <p><strong>Key Points:</strong></p> <ul> <li><strong>Tree Construction from Traversals:</strong> These problems involve constructing a binary tree using given sequences of inorder, preorder, or postorder traversals.</li> <li><strong>Tree Conversion:</strong> These problems require transforming a binary tree into another structure, such as a linked list, string representation, or different binary tree form.</li> <li><strong>Recursive Approach:</strong> Tree construction typically involves recursive methods to correctly position nodes based on traversal orders.</li> </ul> <p><strong>Problems:</strong></p> <ul> <li><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">Construct Binary Tree from Preorder and Inorder Traversal</a></li> <li><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">Construct Binary Tree from Inorder and Postorder Traversal</a></li> <li><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/">Flatten Binary Tree to Linked List</a></li> <li><a href="https://leetcode.com/problems/construct-string-from-binary-tree/description/">Construct String from Binary Tree</a></li> <li><a href="https://leetcode.com/problems/maximum-binary-tree/description/">Maximum Binary Tree</a></li> <li><a href="https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/description/">Recover a Tree from Preorder Traversal</a></li> <li><a href="https://leetcode.com/problems/all-possible-full-binary-trees/description/">All Possible Full Binary Trees</a></li> </ul> <p><strong>Code Example (Construct Binary Tree from Preorder and Inorder Traversal):</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Construct Binary Tree from Preorder and Inorder Traversal in C++</span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
</span>
<span class="n">TreeNode</span><span class="o">*</span> <span class="nf">buildTreeHelper</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">preorder</span><span class="p">,</span> <span class="kt">int</span> <span class="n">preStart</span><span class="p">,</span> <span class="kt">int</span> <span class="n">preEnd</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">inorder</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inStart</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inEnd</span><span class="p">,</span>
                          <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">inorderMap</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">preStart</span> <span class="o">&gt;</span> <span class="n">preEnd</span> <span class="o">||</span> <span class="n">inStart</span> <span class="o">&gt;</span> <span class="n">inEnd</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">rootVal</span> <span class="o">=</span> <span class="n">preorder</span><span class="p">[</span><span class="n">preStart</span><span class="p">];</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">TreeNode</span><span class="p">(</span><span class="n">rootVal</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">rootIndex</span> <span class="o">=</span> <span class="n">inorderMap</span><span class="p">[</span><span class="n">rootVal</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">leftTreeSize</span> <span class="o">=</span> <span class="n">rootIndex</span> <span class="o">-</span> <span class="n">inStart</span><span class="p">;</span>

    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">buildTreeHelper</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">preStart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">preStart</span> <span class="o">+</span> <span class="n">leftTreeSize</span><span class="p">,</span>
                                 <span class="n">inorder</span><span class="p">,</span> <span class="n">inStart</span><span class="p">,</span> <span class="n">rootIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inorderMap</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">buildTreeHelper</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">preStart</span> <span class="o">+</span> <span class="n">leftTreeSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">preEnd</span><span class="p">,</span>
                                  <span class="n">inorder</span><span class="p">,</span> <span class="n">rootIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inEnd</span><span class="p">,</span> <span class="n">inorderMap</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TreeNode</span><span class="o">*</span> <span class="nf">buildTree</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">preorder</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">inorder</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">inorderMap</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inorder</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">inorderMap</span><span class="p">[</span><span class="n">inorder</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">buildTreeHelper</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">preorder</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                           <span class="n">inorder</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">inorder</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inorderMap</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div> <h3 id="explanation-5">Explanation</h3> <p>•Mapping Inorder Indices: A hash map is used to store the indices of values in the inorder traversal, allowing for quick lookups when dividing the tree into left and right subtrees. •Recursive Construction: The tree is constructed recursively by determining the root node from the preorder traversal and dividing the inorder traversal into left and right subtrees. •Handling Subtrees: The left and right subtrees are recursively constructed using the corresponding segments of the preorder and inorder traversals.</p> <h3 id="applications-1">Applications</h3> <p>•Tree Reconstruction: Building a binary tree from traversal data, which is common in parsing tasks, compilers, and data reconstruction. •Tree Transformation: Converting trees into different forms, such as linked lists, strings, or arrays, for use in various algorithms and data processing tasks.</p> <h2 id="pattern-8-advanced-binary-tree-problems">Pattern 8: Advanced Binary Tree Problems</h2> <p><strong>Overview:</strong> Advanced binary tree problems often combine multiple concepts and require deep insights into the structure and properties of binary trees. These problems may involve complex operations such as finding the maximum path sum, serializing and deserializing trees, or placing binary tree cameras to monitor nodes. They typically require a mix of traversal techniques, dynamic programming, and advanced recursion.</p> <p><strong>Key Points:</strong></p> <ul> <li><strong>Maximum Path Sum:</strong> Finding the path in a binary tree where the sum of node values is the highest. This path may start and end at any node.</li> <li><strong>Serialization and Deserialization:</strong> Converting a binary tree into a format that can be stored or transmitted and then reconstructing the tree from that format.</li> <li><strong>Binary Tree Cameras:</strong> Placing cameras in the tree to monitor all nodes with the fewest number of cameras, usually involves dynamic programming or greedy approaches.</li> <li><strong>Combination of Concepts:</strong> Problems in this category often require combining basic tree operations with more advanced techniques like dynamic programming, backtracking, or even graph algorithms.</li> </ul> <p><strong>Problems:</strong></p> <ul> <li><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/description/">Binary Tree Maximum Path Sum</a></li> <li><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/">Serialize and Deserialize Binary Tree</a></li> <li><a href="https://leetcode.com/problems/binary-tree-cameras/">Binary Tree Cameras</a></li> <li><a href="https://leetcode.com/problems/recover-binary-search-tree/">Recover Binary Search Tree</a></li> </ul> <p><strong>Code Example (Binary Tree Maximum Path Sum):</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Binary Tree Maximum Path Sum in C++</span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">maxPathSumHelper</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">maxSum</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="kt">int</span> <span class="n">leftGain</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">maxPathSumHelper</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">maxSum</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">rightGain</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">maxPathSumHelper</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">maxSum</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    
    <span class="kt">int</span> <span class="n">priceNewPath</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="n">leftGain</span> <span class="o">+</span> <span class="n">rightGain</span><span class="p">;</span>
    
    <span class="n">maxSum</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">maxSum</span><span class="p">,</span> <span class="n">priceNewPath</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">leftGain</span><span class="p">,</span> <span class="n">rightGain</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">maxPathSum</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>
    <span class="n">maxPathSumHelper</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">maxSum</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">maxSum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="explanation-6">Explanation</h3> <p>•Recursive Helper Function: The helper function calculates the maximum gain from the left and right subtrees. It ensures that if a subtree’s gain is negative, it is discarded (i.e., treated as 0). •Calculating the Path Sum: The path sum for the current node is calculated by adding the node’s value to the maximum gains from the left and right subtrees. •Updating the Maximum Sum: The global maximum path sum is updated if the current path sum is higher than the previously recorded maximum. •Return Value: The function returns the maximum gain that can be obtained by continuing the path through either the left or right subtree.</p> <h3 id="applications-2">Applications</h3> <p>•Optimal Substructure Problems: Advanced binary tree problems often require finding optimal substructures, such as the maximum path sum that can be formed by combining multiple subtrees. •Data Compression and Transmission: Serialization and deserialization are key in transmitting tree data over networks or storing it in a compressed format. •Security and Monitoring: Placing cameras or other monitoring devices efficiently in hierarchical structures, ensuring minimal coverage overlaps.</p>]]></content><author><name></name></author><category term="problem-solving"/><category term="leetcode"/><summary type="html"><![CDATA[Binary trees are the backbone of countless algorithms. In this blog, we’ll explore their structure, traversal techniques.]]></summary></entry><entry><title type="html">Graph Algorithms Deep Dive Key Concepts and Techniques</title><link href="https://raahulsaxena.github.io/blog/2024/graphs/" rel="alternate" type="text/html" title="Graph Algorithms Deep Dive Key Concepts and Techniques"/><published>2024-08-15T15:09:00+00:00</published><updated>2024-08-15T15:09:00+00:00</updated><id>https://raahulsaxena.github.io/blog/2024/graphs</id><content type="html" xml:base="https://raahulsaxena.github.io/blog/2024/graphs/"><![CDATA[<ol> <li><strong>Graph Representation</strong> <ul> <li>Adjacency Matrix</li> <li>Adjacency List</li> </ul> </li> <li><strong>Graph Traversal</strong> <ul> <li>BFS</li> <li>DFS</li> </ul> </li> <li><strong>Topological Sort</strong> <ul> <li>Using DFS</li> <li>Kahn’s Algorithm</li> </ul> </li> <li><strong>Shortest Path Algorithms</strong> <ul> <li>Dijkstra’s Algorithm</li> <li>Bellman-Ford</li> <li>Floyd-Warshall</li> </ul> </li> <li><strong>Union-Find / Disjoint Set</strong></li> <li><strong>Minimum Spanning Tree</strong> <ul> <li>Prim’s Algorithm</li> <li>Kruskal’s Algorithm</li> </ul> </li> <li><strong>Cycle Detection</strong> <ul> <li>Undirected Graph</li> <li>Directed Graph</li> </ul> </li> <li>Bipartite Graph</li> </ol> <hr/> <h3 id="graph-representation">Graph Representation</h3> <hr/> <h3 id="1-adjacency-matrix"><strong>1. Adjacency Matrix</strong></h3> <h3 id="2-adjacency-list"><strong>2. Adjacency List</strong></h3> <p><strong>C++ Code for both representations:</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="c1">#include &lt;vector&gt;using namespace std;</span><span class="cp">
</span>

<span class="kt">void</span> <span class="nf">adjacencyMatrix</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">adjMatrix</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">adjMatrix</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">adjMatrix</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> 
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">row</span> <span class="o">:</span> <span class="n">adjMatrix</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">val</span> <span class="o">:</span> <span class="n">row</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">adjacencyList</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">adjList</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">adjList</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="n">adjList</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">);</span> 
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">": "</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adjList</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div> <p><strong>Practice Problems:</strong></p> <ol> <li><a href="https://leetcode.com/problems/clone-graph/">LeetCode 133: Clone Graph</a></li> <li><a href="https://leetcode.com/problems/all-paths-from-source-to-target/">LeetCode 797: All Paths From Source to Target</a></li> <li><a href="https://leetcode.com/problems/course-schedule/">LeetCode 207: Course Schedule</a></li> <li><a href="https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/">LeetCode 1557: Minimum Number of Vertices to Reach All Nodes</a></li> <li><a href="https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/">LeetCode 1466: Reorder Routes to Make All Paths Lead to the City Zero</a></li> </ol> <h3 id="graph-traversals-bfs-and-dfs">Graph Traversals (BFS and DFS)</h3> <hr/> <p><strong>C++ Code:</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="c1">#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;</span><span class="cp">
</span>
<span class="c1">// BFS</span>
<span class="kt">void</span> <span class="nf">bfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">adjList</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">node</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">adjList</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">neighbor</span><span class="p">);</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// DFS</span>
<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">adjList</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">visited</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">node</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">adjList</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">adjList</span><span class="p">,</span> <span class="n">visited</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div> <p><strong>Practice Problems:</strong></p> <ol> <li><a href="https://leetcode.com/problems/number-of-islands/">LeetCode 200: Number of Islands</a></li> <li><a href="https://leetcode.com/problems/rotting-oranges/">LeetCode 994: Rotting Oranges</a></li> <li><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">LeetCode 103: Binary Tree Zigzag Level Order Traversal</a></li> <li><a href="https://leetcode.com/problems/surrounded-regions/">LeetCode 130: Surrounded Regions</a></li> <li><a href="https://leetcode.com/problems/jump-game-iii/">LeetCode 1306: Jump Game III</a></li> </ol> <hr/> <h3 id="topological-sort"><strong>Topological Sort</strong></h3> <h3 id="1-using-dfs"><strong>1. Using DFS</strong></h3> <h3 id="2-kahns-algorithm"><strong>2. Kahn’s Algorithm</strong></h3> <p><strong>C++ Code:</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="c1">#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;</span><span class="cp">
</span>
<span class="c1">// Topological Sort using DFS</span>
<span class="kt">void</span> <span class="nf">topoSortDFS</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">adjList</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">visited</span><span class="p">,</span> <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">st</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">adjList</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">topoSortDFS</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">adjList</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">st</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">topologicalSortDFS</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">adjList</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">st</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">topoSortDFS</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">adjList</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">st</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">topoOrder</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">topoOrder</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">());</span>
        <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">topoOrder</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Topological Sort using Kahn's Algorithm (BFS)</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">topologicalSortKahn</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">adjList</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">inDegree</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">adjList</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">inDegree</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">inDegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">topoOrder</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">topoOrder</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">adjList</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">inDegree</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">inDegree</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">neighbor</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">topoOrder</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div> <p><strong>Practice Problems:</strong></p> <ol> <li><a href="https://leetcode.com/problems/course-schedule-ii/">LeetCode 210: Course Schedule II</a></li> <li><a href="https://leetcode.com/problems/find-eventual-safe-states/">LeetCode 802: Find Eventual Safe States</a></li> <li><a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/">LeetCode 329: Longest Increasing Path in a Matrix</a></li> <li><a href="https://leetcode.com/problems/parallel-courses/">LeetCode 1136: Parallel Courses</a></li> <li><a href="https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/">LeetCode 1203: Sort Items by Groups Respecting Dependencies</a></li> </ol> <hr/> <h3 id="shortest-path-algorithms"><strong>Shortest Path Algorithms</strong></h3> <h3 id="1-dijkstras-algorithm"><strong>1. Dijkstra’s Algorithm</strong></h3> <h3 id="2-bellman-ford"><strong>2. Bellman-Ford</strong></h3> <h3 id="3-floyd-warshall"><strong>3. Floyd-Warshall</strong></h3> <p><strong>C++ Code:</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="c1">#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;climits&gt;using namespace std;</span><span class="cp">
</span>
<span class="c1">// Dijkstra's Algorithm</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dijkstra</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&gt;&amp;</span> <span class="n">adjList</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>
    <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">pq</span><span class="p">;</span>
    <span class="n">dist</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">});</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
        <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">adjList</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">neighbor</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">neighbor</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">weight</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">weight</span><span class="p">;</span>
                <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">v</span><span class="p">});</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dist</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Bellman-Ford Algorithm</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bellmanFord</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">edges</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>
    <span class="n">dist</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">weight</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span>

 <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">weight</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dist</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Floyd-Warshall Algorithm</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">floydWarshall</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">graph</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">graph</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dist</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div> <p><strong>Practice Problems:</strong></p> <ol> <li><a href="https://leetcode.com/problems/network-delay-time/">LeetCode 743: Network Delay Time</a></li> <li><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/">LeetCode 787: Cheapest Flights Within K Stops</a></li> <li><a href="https://leetcode.com/problems/path-with-minimum-effort/">LeetCode 1631: Path With Minimum Effort</a></li> <li><a href="https://leetcode.com/problems/path-with-maximum-probability/">LeetCode 1514: Path with Maximum Probability</a></li> <li><a href="https://leetcode.com/problems/shortest-path-with-alternating-colors/">LeetCode 1129: Shortest Path with Alternating Colors</a></li> </ol> <hr/> <h3 id="union-find--disjoint-set"><strong>Union-Find / Disjoint Set</strong></h3> <p><strong>C++ Code:</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="c1">#include &lt;vector&gt;using namespace std;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">UnionFind</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rank</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="n">UnionFind</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">parent</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">rank</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span> <span class="c1">// Path compression</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">unionSets</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">rootX</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">rootY</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">rootX</span> <span class="o">!=</span> <span class="n">rootY</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rank</span><span class="p">[</span><span class="n">rootY</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">rootY</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootX</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="p">[</span><span class="n">rootY</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootY</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">rootY</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootX</span><span class="p">;</span>
                <span class="n">rank</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

</code></pre></div></div> <p><strong>Practice Problems:</strong></p> <ol> <li><a href="https://leetcode.com/problems/redundant-connection/">LeetCode 684: Redundant Connection</a></li> <li><a href="https://leetcode.com/problems/satisfiability-of-equality-equations/">LeetCode 990: Satisfiability of Equality Equations</a></li> <li><a href="https://leetcode.com/problems/accounts-merge/">LeetCode 721: Accounts Merge</a></li> <li><a href="https://leetcode.com/problems/number-of-operations-to-make-network-connected/">LeetCode 1319: Number of Operations to Make Network Connected</a></li> <li><a href="https://leetcode.com/problems/longest-consecutive-sequence/">LeetCode 128: Longest Consecutive Sequence</a></li> </ol> <hr/> <h3 id="minimum-spanning-tree"><strong>Minimum Spanning Tree</strong></h3> <h3 id="1-prims-algorithm"><strong>1. Prim’s Algorithm</strong></h3> <h3 id="2-kruskals-algorithm"><strong>2. Kruskal’s Algorithm</strong></h3> <p><strong>C++ Code:</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">// Prim's Algorithm</span>
<span class="kt">int</span> <span class="nf">primMST</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&gt;&amp;</span> <span class="n">adjList</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">inMST</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">pq</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">mstCost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">});</span> <span class="c1">// (cost, node)</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
        <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">inMST</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>

        <span class="n">mstCost</span> <span class="o">+=</span> <span class="n">cost</span><span class="p">;</span>
        <span class="n">inMST</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">adjList</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">neighbor</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">neighbor</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inMST</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">weight</span><span class="p">,</span> <span class="n">v</span><span class="p">});</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">mstCost</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Kruskal's Algorithm</span>
<span class="k">class</span> <span class="nc">Edge</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="p">;</span>
    <span class="n">Edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">_u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_weight</span><span class="p">)</span> <span class="o">:</span> <span class="n">u</span><span class="p">(</span><span class="n">_u</span><span class="p">),</span> <span class="n">v</span><span class="p">(</span><span class="n">_v</span><span class="p">),</span> <span class="n">weight</span><span class="p">(</span><span class="n">_weight</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="nf">compare</span><span class="p">(</span><span class="n">Edge</span> <span class="n">e1</span><span class="p">,</span> <span class="n">Edge</span> <span class="n">e2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">e1</span><span class="p">.</span><span class="n">weight</span> <span class="o">&lt;</span> <span class="n">e2</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kruskalMST</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;&amp;</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">edges</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">compare</span><span class="p">);</span>
    <span class="n">UnionFind</span> <span class="n">uf</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">mstCost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">uf</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">u</span><span class="p">)</span> <span class="o">!=</span> <span class="n">uf</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">mstCost</span> <span class="o">+=</span> <span class="n">edge</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>
            <span class="n">uf</span><span class="p">.</span><span class="n">unionSets</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">u</span><span class="p">,</span> <span class="n">edge</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">mstCost</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div> <p><strong>Practice Problems:</strong></p> <ol> <li><a href="https://leetcode.com/problems/min-cost-to-connect-all-points/">LeetCode 1584: Min Cost to Connect All Points</a></li> <li><a href="https://leetcode.com/problems/connecting-cities-with-minimum-cost/">LeetCode 1135: Connecting Cities With Minimum Cost</a></li> <li><a href="https://leetcode.com/problems/path-with-minimum-effort/">LeetCode 1631: Path With Minimum Effort</a> <em>(Can be solved with MST)</em></li> <li><a href="https://leetcode.com/problems/the-earliest-moment-when-everyone-become-friends/">LeetCode 1101: The Earliest Moment When Everyone Become Friends</a></li> <li><a href="https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/">LeetCode 1579: Remove Max Number of Edges to Keep Graph Fully Traversable</a></li> </ol> <hr/> <h3 id="cycle-detection"><strong>Cycle Detection</strong></h3> <h3 id="1-undirected-graph"><strong>1. Undirected Graph</strong></h3> <h3 id="2-directed-graph"><strong>2. Directed Graph</strong></h3> <p><strong>C++ Code:</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="c1">#include &lt;vector&gt;using namespace std;</span><span class="cp">
</span>
<span class="c1">// Cycle Detection in Undirected Graph using DFS</span>
<span class="kt">bool</span> <span class="nf">isCyclicDFS</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parent</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">adjList</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">visited</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">adjList</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">isCyclicDFS</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">adjList</span><span class="p">,</span> <span class="n">visited</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">neighbor</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">hasCycleUndirected</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">adjList</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">isCyclicDFS</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">adjList</span><span class="p">,</span> <span class="n">visited</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Cycle Detection in Directed Graph using DFS</span>
<span class="kt">bool</span> <span class="nf">isCyclicDFSDirected</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">adjList</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">visited</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">recStack</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">recStack</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">adjList</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">isCyclicDFSDirected</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">adjList</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">recStack</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">recStack</span><span class="p">[</span><span class="n">neighbor</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">recStack</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">hasCycleDirected</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">adjList</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">recStack</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">isCyclicDFSDirected</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">adjList</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">recStack</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div> <p><strong>Practice Problems:</strong></p> <ol> <li><a href="https://leetcode.com/problems/is-graph-bipartite/">LeetCode 785: Is Graph Bipartite?</a></li> <li><a href="https://leetcode.com/problems/course-schedule/">LeetCode 207: Course Schedule</a> <em>(Directed Graph Cycle Detection)</em></li> <li><a href="https://leetcode.com/problems/graph-valid-tree/">LeetCode 261: Graph Valid Tree</a></li> <li><a href="https://leetcode.com/problems/find-eventual-safe-states/">LeetCode 802: Find Eventual Safe States</a> <em>(Directed Graph Cycle Detection)</em></li> <li><a href="https://leetcode.com/problems/course-schedule-iv/">LeetCode 1462: Course Schedule IV</a> <em>(Cycle detection in multiple queries)</em></li> </ol> <hr/> <h3 id="bipartite-graph"><strong>Bipartite Graph</strong></h3> <p><strong>C++ Code:</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="c1">#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;</span><span class="cp">
</span>
<span class="c1">// Check if Graph is Bipartite using BFS</span>
<span class="kt">bool</span> <span class="nf">isBipartite</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">adjList</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">color</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="n">color</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
                <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">adjList</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="p">{</span>
                    <span class="k">if</span>

 <span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">color</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">color</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
                        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">neighbor</span><span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="n">color</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div> <p><strong>Practice Problems:</strong></p> <ol> <li><a href="https://leetcode.com/problems/is-graph-bipartite/">LeetCode 785: Is Graph Bipartite?</a></li> <li><a href="https://leetcode.com/problems/possible-bipartition/">LeetCode 886: Possible Bipartition</a></li> <li><a href="https://leetcode.com/problems/coloring-a-border/">LeetCode 1034: Coloring A Border</a></li> <li><a href="https://leetcode.com/problems/rotting-oranges/">LeetCode 994: Rotting Oranges</a> <em>(BFS based problem)</em></li> <li><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/">LeetCode 1091: Shortest Path in Binary Matrix</a></li> </ol> <hr/> <p>This theme implements a built-in Jekyll feature, the use of Rouge, for syntax highlighting. It supports more than 100 languages. This example is in C++. All you have to do is wrap your code in markdown code tags:</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">```</span><span class="nl">c++
</span><span class="n">code</span> <span class="n">code</span> <span class="n">code</span>
<span class="p">```</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="err">\</span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">myString</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"input a string: "</span><span class="p">;</span>
    <span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">myString</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">myString</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>

    <span class="kt">char</span> <span class="n">charArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span> <span class="o">*</span> <span class="p">[</span><span class="n">length</span><span class="p">];</span>

    <span class="n">charArray</span> <span class="o">=</span> <span class="n">myString</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">charArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>For displaying code in a list item, you have to be aware of the indentation, as stated in this <a href="https://stackoverflow.com/questions/34987908/embed-a-code-block-in-a-list-item-with-proper-indentation-in-kramdown/38090598#38090598">Stackoverflow answer</a>. You must indent your code by <strong>(3 * bullet_indent_level)</strong> spaces. This is because kramdown (the markdown engine used by Jekyll) indentation for the code block in lists is determined by the column number of the first non-space character after the list item marker. For example:</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">1.</span> We can put fenced code blocks inside nested bullets, too.
<span class="p">
   1.</span> Like this:<span class="sb">

      ```c
      printf("Hello, World!");
      ```

</span><span class="p">   2.</span> The key is to indent your fenced block in the same line as the first character of the line.
</code></pre></div></div> <p>Which displays:</p> <ol> <li> <p>We can put fenced code blocks inside nested bullets, too.</p> <ol> <li> <p>Like this:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">printf</span><span class="p">(</span><span class="s">"Hello, World!"</span><span class="p">);</span>
</code></pre></div> </div> </li> <li> <p>The key is to indent your fenced block in the same line as the first character of the line.</p> </li> </ol> </li> </ol> <p>By default, it does not display line numbers. If you want to display line numbers for every code block, you can set <code class="language-plaintext highlighter-rouge">kramdown.syntax_highlighter_opts.block.line_numbers</code> to true in your <code class="language-plaintext highlighter-rouge">_config.yml</code> file.</p> <p>If you want to display line numbers for a specific code block, all you have to do is wrap your code in a liquid tag:</p> <p>{% highlight c++ linenos %} <br/> code code code <br/> {% endhighlight %}</p> <p>The keyword <code class="language-plaintext highlighter-rouge">linenos</code> triggers display of line numbers. Produces something like this:</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="err">\</span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="n">string</span> <span class="n">myString</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"input a string: "</span><span class="p">;</span>
    <span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">myString</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">myString</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>

    <span class="kt">char</span> <span class="n">charArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span> <span class="o">*</span> <span class="p">[</span><span class="n">length</span><span class="p">];</span>

    <span class="n">charArray</span> <span class="o">=</span> <span class="n">myString</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">charArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="code"/><summary type="html"><![CDATA[Explore the core concepts and algorithms in graph theory.]]></summary></entry><entry><title type="html">Let’s do Dynamic Programming</title><link href="https://raahulsaxena.github.io/blog/2024/dp-study-plan/" rel="alternate" type="text/html" title="Let’s do Dynamic Programming"/><published>2024-08-13T15:09:00+00:00</published><updated>2024-08-13T15:09:00+00:00</updated><id>https://raahulsaxena.github.io/blog/2024/dp-study-plan</id><content type="html" xml:base="https://raahulsaxena.github.io/blog/2024/dp-study-plan/"><![CDATA[<p>This page is continually updated with new and improved content to ensure the best curation for Dynamic Programming problems.</p> <h2 id="important-links">Important Links:</h2> <ul> <li>Source : Striver SDE Sheet,</li> <li><a href="https://www.reddit.com/r/leetcode/comments/14o10jd/the_ultimate_dynamic_programming_roadmap/">Ultimate Dynamic Programming Roadmap</a></li> <li><a href="https://www.youtube.com/watch?v=9k31KcQmS_U&amp;ab_channel=AlgoMonster">Youtube Link</a> <a href="https://leetcode.com/discuss/study-guide/458695/Dynamic-Programming-Patterns">- DP Patterns (Coded)</a></li> <li><a href="https://leetcode.com/discuss/study-guide/1000929/solved-all-dynamic-programming-dp-problems-in-7-months">All DP Problems sorted patterwise</a></li> </ul> <h2 id="pattern-1-01-knapsack-bounded">Pattern 1: 0/1 Knapsack (Bounded)</h2> <p>Solution is built upon subset, but with few more restrictions. For example you want to complete some courses, they have some reward points associated. But you can attend only k number of courses. Now try to maximize your points. This type of problems are just an extension to simple DP, where you add one more dimension to consider provided restriction.</p> <h3 id="problems">Problems:</h3> <ul> <li><a href="https://leetcode.com/problems/partition-equal-subset-sum/">Partition Equal Subset Sum</a></li> <li><a href="https://leetcode.com/problems/last-stone-weight-ii/">Last Stone Weight II</a></li> <li><a href="https://leetcode.com/problems/target-sum/">Target Sum</a></li> </ul> <h2 id="pattern-2-01-knapsack-unbounded">Pattern 2: 0/1 Knapsack (Unbounded)</h2> <p>Dp state is similar to the classical knapsack problem.</p> <h3 id="problems-1">Problems:</h3> <ul> <li><a href="https://leetcode.com/problems/coin-change/description/">Coin Change I</a></li> <li><a href="https://leetcode.com/problems/coin-change-ii/description/">Coin Change II</a></li> </ul> <h2 id="pattern-3-fibonacci-or-linear-dp">Pattern 3: Fibonacci (or Linear DP)</h2> <p>You just need to find the repetitive part of the solution and improve it by saving its result.</p> <p>Dp solution requires us to solve the sub problem on every prefix of the array. A prefix of the array is a subarray from 0 to i for some i.</p> <h3 id="problems-2">Problems:</h3> <ul> <li><a href="https://leetcode.com/problems/fibonacci-number/">Fibonacci Number</a></li> <li><a href="https://leetcode.com/problems/climbing-stairs/">Climbing Stairs</a></li> <li><a href="https://leetcode.com/problems/min-cost-climbing-stairs/">Min Cost Climbing Stairs</a></li> <li><a href="https://leetcode.com/problems/house-robber/">House Robber I</a></li> <li><a href="https://leetcode.com/problems/house-robber-ii/">House Robber II</a></li> <li><a href="https://leetcode.com/problems/decode-ways/">Decode Ways</a></li> </ul> <h2 id="pattern-4-string-dp">Pattern 4: String DP</h2> <h3 id="problems-3">Problems:</h3> <ul> <li><a href="https://leetcode.com/problems/is-subsequence/">Is Subsequence</a></li> <li><a href="https://leetcode.com/problems/palindrome-partitioning/">Palindromic Partitioning I</a></li> <li><a href="https://leetcode.com/problems/palindrome-partitioning-ii/">Palindromic Partitioning II</a></li> <li><a href="https://leetcode.com/problems/word-break/">Word Break</a></li> <li><a href="https://leetcode.com/problems/longest-valid-parentheses/">Longest Valid Parentheses</a></li> <li><a href="https://leetcode.com/problems/word-break-ii/">Word Break II</a></li> <li><a href="https://leetcode.com/problems/concatenated-words/description/">Concatenated Words</a></li> <li><a href="https://leetcode.com/problems/distinct-subsequences/description/">Distinct Subsequences</a></li> </ul> <h2 id="pattern-5-longest-common-subsequence-lcs-string-dp">Pattern 5: Longest Common Subsequence (LCS) [String DP]</h2> <h3 id="problems-4">Problems:</h3> <ul> <li><a href="https://leetcode.com/problems/longest-common-subsequence/">Longest Common Subsequence</a></li> <li><a href="https://leetcode.com/problems/maximum-length-of-repeated-subarray/">Maximum length of repeated Subarray</a></li> <li><a href="https://leetcode.com/problems/edit-distance/description/?envType=problem-list-v2&amp;envId=55afh7m7">Edit Distance</a></li> <li><a href="https://leetcode.com/problems/interleaving-string/">Interleaving String</a></li> <li><a href="https://leetcode.com/problems/longest-happy-string/description/">Longest Happy String</a></li> <li><a href="https://leetcode.com/problems/longest-string-chain/description/">Longest String Chain</a></li> <li><a href="https://leetcode.com/problems/shortest-common-supersequence/">Shortest Common Supersequence</a></li> <li><a href="https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/description/">Minimum Insertion Steps to Make a String Palindrome</a></li> </ul> <h2 id="pattern-6-palindromes-lcs">Pattern 6: Palindromes (LCS)</h2> <h3 id="problems-5">Problems:</h3> <ul> <li><a href="https://leetcode.com/problems/longest-palindromic-substring/">Longest Palindromic Substring</a></li> <li><a href="https://leetcode.com/problems/longest-palindromic-subsequence/">Longest Palindromic Subsequence</a></li> <li><a href="https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/description/">Minimum Insertion Steps to make a string Palindrome</a></li> <li><a href="https://leetcode.com/problems/valid-palindrome-iii/">Valid Palindrome III</a></li> <li><a href="https://leetcode.com/problems/palindromic-substrings/">Palindromic Substrings</a></li> </ul> <h2 id="pattern-7-longest-increasing-subsequence-lis">Pattern 7: Longest Increasing Subsequence (LIS)</h2> <p>Dp problem is solved on every prefix of the array. Transition is from every index j &lt; i.</p> <h3 id="problems-6">Problems:</h3> <ul> <li><a href="https://leetcode.com/problems/longest-increasing-subsequence/">Longest Increasing Subsequence</a></li> <li><a href="https://leetcode.com/problems/russian-doll-envelopes/">Russian Doll Envelops</a></li> <li><a href="https://leetcode.com/problems/number-of-longest-increasing-subsequence/">Number of Longest Increasing Subsequence</a></li> <li><a href="https://leetcode.com/problems/make-array-strictly-increasing/description/">Make Array Strictly Increasing</a></li> </ul> <h2 id="pattern-8-matrix-chain-multiplication">Pattern 8: Matrix Chain Multiplication</h2> <p>Dp problem is solved on every single interval (subarray) of the array.</p> <h3 id="problems-7">Problems:</h3> <ul> <li><a href="https://leetcode.com/problems/remove-boxes/">Remove Boxes</a></li> <li><a href="https://leetcode.com/problems/unique-binary-search-trees/">Unique Binary Search Trees</a></li> <li><a href="https://leetcode.com/problems/burst-balloons/">Burst Balloons</a></li> <li><a href="https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/">Minimum Cost Tree from Leaf Values</a></li> </ul> <h2 id="pattern-9-kadanes-algorithm">Pattern 9: Kadane’s Algorithm</h2> <h3 id="problems-8">Problems:</h3> <ul> <li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">Best Time to Buy and Sell Stock</a></li> <li><a href="https://leetcode.com/problems/maximum-subarray/">Maximum Subarray</a></li> <li><a href="https://leetcode.com/problems/maximum-product-subarray/">Maximum Product Subarray</a></li> <li><a href="https://leetcode.com/problems/longest-turbulent-subarray/description/">Longest Turbulent Subarray</a></li> <li><a href="https://leetcode.com/problems/largest-divisible-subset/description/">Largest Divisible Subset</a></li> </ul> <h2 id="pattern-10-dp-on-trees">Pattern 10: DP on Trees</h2> <h3 id="problems-9">Problems:</h3> <ul> <li><a href="https://leetcode.com/problems/binary-tree-cameras/description/">Binary Tree Cameras</a></li> <li><a href="https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/description/">Maximum Sum BST in Binary Tree</a></li> <li><a href="https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/description/">Longest ZigZag Path in a Binary Tree</a></li> <li><a href="https://leetcode.com/problems/house-robber-iii/description/">House Robber III</a></li> <li><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/description/">Unique Binary Search Trees II</a></li> </ul> <h2 id="pattern-11-grid-dp">Pattern 11: Grid DP</h2> <p>Dp table will have the same dimensions as grid, the state at cell i,j will be related to the grid at cell i,j.</p> <h3 id="problems-10">Problems:</h3> <ul> <li><a href="https://leetcode.com/problems/matrix-block-sum/">Matrix Block Sum</a></li> <li><a href="https://leetcode.com/problems/dungeon-game/">Dungeon Game</a></li> <li><a href="https://leetcode.com/problems/maximal-square/">Maximal Square</a></li> <li><a href="https://leetcode.com/problems/minimum-falling-path-sum/">Minimum Falling Path Sum</a></li> <li><a href="https://leetcode.com/problems/unique-paths/">Unique Paths</a></li> <li><a href="https://leetcode.com/problems/unique-paths-ii/">Unique Paths II</a></li> <li><a href="https://leetcode.com/problems/minimum-path-sum/">Minimum Path Sum</a></li> </ul> <h2 id="pattern-12-dp--bitmask">Pattern 12: DP + Bitmask</h2> <h3 id="problems-11">Problems:</h3> <ul> <li><a href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets/">Partition to K equal Sum Subsets</a></li> <li><a href="https://leetcode.com/problems/stickers-to-spell-word/">Stickers to Spell Word</a></li> <li><a href="https://leetcode.com/problems/shortest-path-visiting-all-nodes/">Shortest Path Visiting All Nodes</a></li> </ul> <h2 id="pattern-13-graph-dp">Pattern 13: Graph DP</h2> <h3 id="problems-12">Problems:</h3> <ul> <li><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/">Cheapest Flights within K Stops</a></li> <li><a href="https://leetcode.com/problems/find-the-shortest-superstring/">Find the shortest superstring</a></li> </ul>]]></content><author><name></name></author><category term="sample-posts"/><category term="leetcode"/><summary type="html"><![CDATA[The best dynamic programming study plan (incl. questions)]]></summary></entry><entry><title type="html">Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra</title><link href="https://raahulsaxena.github.io/blog/2024/google-gemini-updates-flash-15-gemma-2-and-project-astra/" rel="alternate" type="text/html" title="Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra"/><published>2024-05-14T00:00:00+00:00</published><updated>2024-05-14T00:00:00+00:00</updated><id>https://raahulsaxena.github.io/blog/2024/google-gemini-updates-flash-15-gemma-2-and-project-astra</id><content type="html" xml:base="https://raahulsaxena.github.io/blog/2024/google-gemini-updates-flash-15-gemma-2-and-project-astra/"><![CDATA[<p>May 14, 2024[[read-time]] min read We’re introducing a series of updates across the Gemini family of models, including the new 1.5 Flash, our lightweight model for speed and efficiency, and Project Astra, our vision for the future of AI assistants. In December, we launched our first natively multimodal model Gemini 1.0 in three sizes: Ultra, Pro and Nano. Just a few months later we released 1.5 Pro, with enhanced performance and a breakthrough long context window of 1 million tokens.Developers and enterprise customers have been putting 1.5 Pro to use in incredible ways and finding its long context window, multimodal reasoning capabilities and impressive overall performance incredibly useful.We know from user feedback that some applications need lower latency and a lower cost to serve. This inspired us to keep innovating, so today, we’re introducing Gemini 1.5 Flash: a model that’s lighter-weight than 1.5 Pro, and designed to be fast and efficient to serve at scale.Both 1.5 Pro and 1.5 Flash are available in public preview with a 1 million token context window in Google AI Studio and Vertex AI. And now, 1.5 Pro is also available with a 2 million token context window via waitlist to developers using the API and to Google Cloud customers.We’re also introducing updates across the Gemini family of models, announcing our next generation of open models, Gemma 2, and sharing progress on the future of AI assistants, with Project Astra.Context lengths of leading foundation models compared with Gemini 1.5’s 2 million token capability1.5 Flash is the newest addition to the Gemini model family and the fastest Gemini model served in the API. It’s optimized for high-volume, high-frequency tasks at scale, is more cost-efficient to serve and features our breakthrough long context window.While it’s a lighter weight model than 1.5 Pro, it’s highly capable of multimodal reasoning across vast amounts of information and delivers impressive quality for its size.The new Gemini 1.5 Flash model is optimized for speed and efficiency, is highly capable of multimodal reasoning and features our breakthrough long context window.1.5 Flash excels at summarization, chat applications, image and video captioning, data extraction from long documents and tables, and more. This is because it’s been trained by 1.5 Pro through a process called “distillation,” where the most essential knowledge and skills from a larger model are transferred to a smaller, more efficient model.Read more about 1.5 Flash in our updated Gemini 1.5 technical report, on the Gemini technology page, and learn about 1.5 Flash’s availability and pricing.Over the last few months, we’ve significantly improved 1.5 Pro, our best model for general performance across a wide range of tasks.Beyond extending its context window to 2 million tokens, we’ve enhanced its code generation, logical reasoning and planning, multi-turn conversation, and audio and image understanding through data and algorithmic advances. We see strong improvements on public and internal benchmarks for each of these tasks.1.5 Pro can now follow increasingly complex and nuanced instructions, including ones that specify product-level behavior involving role, format and style. We’ve improved control over the model’s responses for specific use cases, like crafting the persona and response style of a chat agent or automating workflows through multiple function calls. And we’ve enabled users to steer model behavior by setting system instructions.We added audio understanding in the Gemini API and Google AI Studio, so 1.5 Pro can now reason across image and audio for videos uploaded in Google AI Studio. And we’re now integrating 1.5 Pro into Google products, including Gemini Advanced and in Workspace apps.Read more about 1.5 Pro in our updated Gemini 1.5 technical report and on the Gemini technology page.Gemini Nano is expanding beyond text-only inputs to include images as well. Starting with Pixel, applications using Gemini Nano with Multimodality will be able to understand the world the way people do — not just through text, but also through sight, sound and spoken language.Read more about Gemini 1.0 Nano on Android.Today, we’re also sharing a series of updates to Gemma, our family of open models built from the same research and technology used to create the Gemini models.We’re announcing Gemma 2, our next generation of open models for responsible AI innovation. Gemma 2 has a new architecture designed for breakthrough performance and efficiency, and will be available in new sizes.The Gemma family is also expanding with PaliGemma, our first vision-language model inspired by PaLI-3. And we’ve upgraded our Responsible Generative AI Toolkit with LLM Comparator for evaluating the quality of model responses.Read more on the Developer blog.As part of Google DeepMind’s mission to build AI responsibly to benefit humanity, we’ve always wanted to develop universal AI agents that can be helpful in everyday life. That’s why today, we’re sharing our progress in building the future of AI assistants with Project Astra (advanced seeing and talking responsive agent).To be truly useful, an agent needs to understand and respond to the complex and dynamic world just like people do — and take in and remember what it sees and hears to understand context and take action. It also needs to be proactive, teachable and personal, so users can talk to it naturally and without lag or delay.While we’ve made incredible progress developing AI systems that can understand multimodal information, getting response time down to something conversational is a difficult engineering challenge. Over the past few years, we’ve been working to improve how our models perceive, reason and converse to make the pace and quality of interaction feel more natural.Building on Gemini, we’ve developed prototype agents that can process information faster by continuously encoding video frames, combining the video and speech input into a timeline of events, and caching this information for efficient recall.By leveraging our leading speech models, we also enhanced how they sound, giving the agents a wider range of intonations. These agents can better understand the context they’re being used in, and respond quickly, in conversation.With technology like this, it’s easy to envision a future where people could have an expert AI assistant by their side, through a phone or glasses. And some of these capabilities are coming to Google products, like the Gemini app and web experience, later this year.We’ve made incredible progress so far with our family of Gemini models, and we’re always striving to advance the state-of-the-art even further. By investing in a relentless production line of innovation, we’re able to explore new ideas at the frontier, while also unlocking the possibility of new and exciting Gemini use cases.Learn more about Gemini and its capabilities. Your information will be used in accordance with Google’s privacy policy.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      Done. Just one step more.
    
      Check your inbox to confirm your subscription.
    You are already subscribed to our newsletter.
    You can also subscribe with a
    different email address
    
    .
    
  Let’s stay in touch. Get the latest news from Google in your inbox.
          Follow Us
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[We’re sharing updates across our Gemini family of models and a glimpse of Project Astra, our vision for the future of AI assistants.]]></summary></entry><entry><title type="html">Displaying External Posts on Your al-folio Blog</title><link href="https://raahulsaxena.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog/" rel="alternate" type="text/html" title="Displaying External Posts on Your al-folio Blog"/><published>2022-04-23T23:20:09+00:00</published><updated>2022-04-23T23:20:09+00:00</updated><id>https://raahulsaxena.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog</id><content type="html" xml:base="https://raahulsaxena.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog/"><![CDATA[<h3>External Posts on Your al-folio Blog</h3> <p>If you prefer publishing blog posts on medium.com or other external sources, starting version v0.5.0, <a href="https://github.com/alshedivat/al-folio">al-folio</a> lets you to display your external posts in the blog feed of your website! 🎉🎉</p> <p>Configuring external sources of super simple. After upgrading to v0.5.0, just add the following section to your _config.yml:</p> <pre>external_sources:<br />  - name: medium.com  # name of the source (arbitrary string)<br />    rss_url: <a href="https://medium.com/@al-folio/feed">https://medium.com/@&lt;your-medium-username&gt;/feed</a></pre> <p>The example above adds your medium.com blog post feed as an external source. But you can add arbitrary RSS feeds as sources.</p> <p>Any questions or suggestions? 👉 Start <a href="https://github.com/alshedivat/al-folio/discussions">a discussion on GitHub</a>!</p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b60a1d241a0a" width="1" height="1" alt=""/></p>]]></content><author><name></name></author></entry></feed>