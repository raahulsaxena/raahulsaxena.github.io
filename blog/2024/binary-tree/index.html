<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Branching Out A Deep Dive into Binary Trees | Rahul Saxena </title> <meta name="author" content="Rahul Saxena"> <meta name="description" content="Binary trees are the backbone of countless algorithms. In this blog, we’ll explore their structure, traversal techniques."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://raahulsaxena.github.io/blog/2024/binary-tree/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Rahul</span> Saxena </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/books/">bookshelf</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Branching Out A Deep Dive into Binary Trees</h1> <p class="post-meta"> Created on September 13, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/leetcode"> <i class="fa-solid fa-hashtag fa-sm"></i> leetcode</a>   ·   <a href="/blog/category/problem-solving"> <i class="fa-solid fa-tag fa-sm"></i> problem-solving</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>Binary trees are a fundamental data structure in computer science, often used in various applications ranging from databases to operating systems. Understanding the different types of problems and patterns associated with binary trees is essential for anyone looking to master data structures and algorithms. In this guide, we will explore key binary tree problem patterns and provide examples for each.</p> <h3 id="prerequisites">Prerequisites</h3> <p>Before diving into binary tree problems, it’s important to have a solid grasp of the following concepts:</p> <ul> <li><strong>Recursion</strong></li> <li><strong>Stack and Queue data structures</strong></li> <li><strong>Tree Traversals (Inorder, Preorder, Postorder)</strong></li> </ul> <h2 id="important-binary-tree-patterns">Important Binary Tree Patterns</h2> <h2 id="pattern-1-tree-traversals">Pattern 1: Tree Traversals</h2> <h3 id="overview">Overview</h3> <p>Tree traversals are fundamental operations in binary trees, where each node in the tree is visited in a systematic way. The most common traversals are Inorder, Preorder, and Postorder.</p> <p><strong>Problems:</strong></p> <ul> <li> <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/" rel="external nofollow noopener" target="_blank">Inorder Traversal</a> (Iterative and Recursive)</li> <li> <a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/" rel="external nofollow noopener" target="_blank">Preorder Traversal</a> (Iterative and Recursive)</li> <li> <a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/" rel="external nofollow noopener" target="_blank">Postorder Traversal</a> (Iterative and Recursive)</li> <li><a href="https://leetcode.com/problems/recover-binary-search-tree/" rel="external nofollow noopener" target="_blank">Morris Inorder Traversal</a></li> <li><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/" rel="external nofollow noopener" target="_blank">Morris Preorder Traversal</a></li> </ul> <p><strong>Code Example (Inorder Traversal - Iterative):</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Iterative Inorder Traversal in C++</span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">stack</span><span class="p">;</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="pattern-2-level-order-traversal">Pattern 2: Level Order Traversal</h2> <p><strong>Overview:</strong> Level Order Traversal, also known as Breadth-First Search (BFS) for trees, involves visiting all the nodes level by level, from left to right. It’s commonly used to solve problems where you need to examine nodes on the same level of the tree.</p> <p><strong>Key Points:</strong></p> <ul> <li>Use a queue to keep track of nodes at the current level.</li> <li>Process nodes level by level, adding their children to the queue.</li> <li>This approach is particularly useful for problems that involve hierarchical data.</li> </ul> <p><strong>Problems:</strong></p> <ul> <li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" rel="external nofollow noopener" target="_blank">Level Order Traversal</a></li> <li><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/" rel="external nofollow noopener" target="_blank">Zigzag Level Order Traversal</a></li> <li><a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/" rel="external nofollow noopener" target="_blank">Vertical Order Traversal</a></li> <li><a href="https://leetcode.com/problems/binary-tree-right-side-view/description/" rel="external nofollow noopener" target="_blank">Binary Tree Right Side View</a></li> </ul> <p><strong>Code Example (Level Order Traversal):</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Level Order Traversal in C++</span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">levelOrder</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">level</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">level</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="explanation">Explanation</h3> <p>•A queue is used to store nodes of the tree. •The size of the queue at each level is captured to determine the number of nodes on that level. •Nodes are processed one level at a time, and their children are added to the queue for the next level.</p> <h2 id="pattern-3-views-of-binary-tree">Pattern 3: Views of Binary Tree</h2> <p><strong>Overview:</strong> The “views” of a binary tree refer to the nodes that are visible when the tree is viewed from different perspectives: top, left, right, and boundary views. These problems require traversing the tree in a way that simulates how the tree would look from a specific direction.</p> <p><strong>Key Points:</strong></p> <ul> <li> <strong>Top View:</strong> Nodes visible when the tree is viewed from the top.</li> <li> <strong>Left View:</strong> Nodes visible when the tree is viewed from the left side.</li> <li> <strong>Right View:</strong> Nodes visible when the tree is viewed from the right side.</li> <li> <strong>Boundary View:</strong> Combination of the left boundary, leaves, and right boundary.</li> </ul> <p><strong>Problems:</strong></p> <ul> <li><a href="https://www.geeksforgeeks.org/problems/top-view-of-binary-tree/1" rel="external nofollow noopener" target="_blank">Top View of Binary Tree</a></li> <li><a href="https://www.geeksforgeeks.org/problems/left-view-of-binary-tree/1" rel="external nofollow noopener" target="_blank">Left View of Binary Tree</a></li> <li><a href="https://leetcode.com/problems/binary-tree-right-side-view/description/" rel="external nofollow noopener" target="_blank">Binary Tree Right Side View</a></li> <li><a href="https://leetcode.com/problems/boundary-of-binary-tree/description/" rel="external nofollow noopener" target="_blank">Boundary of a Binary Tree</a></li> </ul> <p><strong>Code Example (Right Side View):</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Right Side View of Binary Tree in C++</span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rightSideView</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span> <span class="c1">// Last node on this level</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="explanation-1">Explanation:</h3> <p>• A queue is used for level-order traversal. • For the right side view, the last node of each level is added to the result. • Similar approaches can be adapted for top, left, and boundary views, with modifications to focus on the specific nodes that should be visible.</p> <h2 id="pattern-4-binary-tree-properties-and-depth-calculations">Pattern 4: Binary Tree Properties and Depth Calculations</h2> <p><strong>Overview:</strong> Binary tree properties and depth calculations involve determining various metrics related to the structure of a tree, such as its depth, height, diameter, and width. These problems often require recursive approaches to traverse the tree and calculate the desired properties.</p> <p><strong>Key Points:</strong></p> <ul> <li> <strong>Maximum/Minimum Depth:</strong> The number of nodes along the longest/shortest path from the root node down to the farthest/nearest leaf node.</li> <li> <strong>Balanced Binary Tree:</strong> A binary tree is balanced if the depth of the two subtrees of every node never differs by more than one.</li> <li> <strong>Diameter:</strong> The length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</li> <li> <strong>Width:</strong> The maximum number of nodes at any level of the binary tree.</li> </ul> <p><strong>Problems:</strong></p> <ul> <li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" rel="external nofollow noopener" target="_blank">Maximum Depth of Binary Tree</a></li> <li><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/" rel="external nofollow noopener" target="_blank">Minimum Depth of Binary Tree</a></li> <li><a href="https://leetcode.com/problems/balanced-binary-tree/" rel="external nofollow noopener" target="_blank">Balanced Binary Tree</a></li> <li><a href="https://leetcode.com/problems/diameter-of-binary-tree/description/" rel="external nofollow noopener" target="_blank">Diameter of Binary Tree</a></li> <li><a href="https://leetcode.com/problems/maximum-width-of-binary-tree/description/" rel="external nofollow noopener" target="_blank">Maximum Width of Binary Tree</a></li> <li><a href="https://leetcode.com/problems/invert-binary-tree/description/" rel="external nofollow noopener" target="_blank">Invert Binary Tree</a></li> <li><a href="https://leetcode.com/problems/find-leaves-of-binary-tree/description/" rel="external nofollow noopener" target="_blank">Find Leaves of Binary Tree</a></li> <li><a href="https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/" rel="external nofollow noopener" target="_blank">Maximum Level Sum of a Binary Tree</a></li> <li><a href="https://leetcode.com/problems/deepest-leaves-sum/description/" rel="external nofollow noopener" target="_blank">Deepest Leaves Sum</a></li> </ul> <p><strong>Code Example (Maximum Depth of Binary Tree):</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Maximum Depth of Binary Tree in C++</span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">leftDepth</span> <span class="o">=</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">rightDepth</span> <span class="o">=</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">leftDepth</span><span class="p">,</span> <span class="n">rightDepth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="explanation-2">Explanation</h3> <p>•Maximum Depth: This is calculated by recursively finding the depth of the left and right subtrees and returning the maximum of the two, plus one for the current node. •Balanced Binary Tree: For checking if a tree is balanced, you can calculate the depth of each subtree and ensure that the difference is no more than one at every node. •Diameter: To find the diameter, calculate the depth of left and right subtrees for each node and track the maximum sum of these depths across all nodes. •Width: Use level order traversal to count the number of nodes at each level and keep track of the maximum.</p> <h2 id="pattern-5-lowest-common-ancestor-lca">Pattern 5: Lowest Common Ancestor (LCA)</h2> <p><strong>Overview:</strong> The Lowest Common Ancestor (LCA) of two nodes in a binary tree is the deepest node that is an ancestor of both nodes. This concept is widely used in problems involving relationships between nodes in a tree, such as finding common ancestors or determining hierarchical structures.</p> <p><strong>Key Points:</strong></p> <ul> <li> <strong>LCA in Binary Tree:</strong> In a general binary tree, the LCA is found by recursively traversing the tree. If a node matches one of the target nodes, it’s returned as a potential LCA.</li> <li> <strong>LCA in Binary Search Tree (BST):</strong> In a BST, the LCA can be found more efficiently by leveraging the properties of the BST. The search is guided by comparing node values.</li> <li> <strong>Applications:</strong> LCA problems are often used in scenarios involving hierarchical data, such as organizational charts, genealogical trees, and file systems.</li> </ul> <p><strong>Problems:</strong></p> <ul> <li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" rel="external nofollow noopener" target="_blank">Lowest Common Ancestor of a Binary Tree</a></li> <li><a href="https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/description/" rel="external nofollow noopener" target="_blank">Maximum Difference Between Node and Ancestor</a></li> <li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/description/" rel="external nofollow noopener" target="_blank">Lowest Common Ancestor of Deepest Leaves</a></li> <li><a href="https://leetcode.com/problems/kth-ancestor-of-a-tree-node/description/" rel="external nofollow noopener" target="_blank">Kth Ancestor of a Tree Node</a></li> </ul> <p><strong>Code Example (LCA in a Binary Tree):</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Lowest Common Ancestor in a Binary Tree in C++</span>
<span class="n">TreeNode</span><span class="o">*</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="n">root</span> <span class="o">==</span> <span class="n">p</span> <span class="o">||</span> <span class="n">root</span> <span class="o">==</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">left</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">right</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">?</span> <span class="n">left</span> <span class="o">:</span> <span class="n">right</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="explanation-3">Explanation</h3> <p>•Recursive Approach: The LCA is found by recursively searching the left and right subtrees. If both the left and right subtree contain one of the nodes, then the current node is the LCA. If only one subtree contains both nodes, that subtree contains the LCA. •Edge Cases: If either p or q is the root, then the root itself is the LCA. If both nodes are found in the same subtree, the LCA is in that subtree.</p> <h2 id="pattern-6-rooted-path---root-to-leaf">Pattern 6: Rooted Path - Root to Leaf</h2> <p><strong>Overview:</strong> Rooted path problems involve finding and analyzing paths from the root node to leaf nodes in a binary tree. These problems often require calculating sums, checking for specific properties along the path, or generating all possible paths from the root to leaves.</p> <p><strong>Key Points:</strong></p> <ul> <li> <strong>Root to Leaf Paths:</strong> These problems generally require traversing the tree to collect or analyze the data from the root to each leaf node.</li> <li> <strong>Path Sum Calculations:</strong> Many problems involve calculating the sum of node values along a root-to-leaf path and checking against a target sum.</li> <li> <strong>Backtracking:</strong> Often, backtracking is used to explore all possible paths from the root to the leaf nodes, making sure to revert changes to the path as you backtrack up the tree.</li> </ul> <p><strong>Problems:</strong></p> <ul> <li><a href="https://leetcode.com/problems/binary-tree-paths/description/" rel="external nofollow noopener" target="_blank">Binary Tree Paths</a></li> <li><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/description/" rel="external nofollow noopener" target="_blank">Sum Root to Leaf Numbers</a></li> <li><a href="https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/description/" rel="external nofollow noopener" target="_blank">Pseudo-Palindromic Paths in a Binary Tree</a></li> <li><a href="https://leetcode.com/problems/path-sum-iii/description/" rel="external nofollow noopener" target="_blank">Path Sum III</a></li> </ul> <p><strong>Code Example (Binary Tree Paths):</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Binary Tree Paths in C++</span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">findPaths</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">paths</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    
    <span class="n">path</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">paths</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span> <span class="c1">// Leaf node</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">path</span> <span class="o">+=</span> <span class="s">"-&gt;"</span><span class="p">;</span>
        <span class="n">findPaths</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">paths</span><span class="p">);</span>
        <span class="n">findPaths</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">paths</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">binaryTreePaths</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">paths</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="n">findPaths</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="n">paths</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">paths</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="explanation-4">Explanation</h3> <p>•Recursive Traversal: The tree is traversed recursively, constructing a path string as you go from the root to each leaf node. •Leaf Nodes: When a leaf node is reached (a node with no children), the constructed path is added to the list of paths. •Backtracking: After exploring one path, the function backtracks to explore alternative paths from the root to other leaf nodes.</p> <h3 id="applications">Applications</h3> <p>•Path Generation: Generating all paths from the root to leaf nodes in hierarchical structures like file systems or organizational charts. •Sum Calculations: Problems that involve finding paths that sum up to a specific value, commonly used in financial or decision-making models.</p> <h2 id="pattern-7-tree-construction-and-conversion">Pattern 7: Tree Construction and Conversion</h2> <p><strong>Overview:</strong> Tree construction and conversion problems involve creating a binary tree from given traversal orders or converting a tree into a different structure. These problems often require a deep understanding of tree properties and traversal methods.</p> <p><strong>Key Points:</strong></p> <ul> <li> <strong>Tree Construction from Traversals:</strong> These problems involve constructing a binary tree using given sequences of inorder, preorder, or postorder traversals.</li> <li> <strong>Tree Conversion:</strong> These problems require transforming a binary tree into another structure, such as a linked list, string representation, or different binary tree form.</li> <li> <strong>Recursive Approach:</strong> Tree construction typically involves recursive methods to correctly position nodes based on traversal orders.</li> </ul> <p><strong>Problems:</strong></p> <ul> <li><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/" rel="external nofollow noopener" target="_blank">Construct Binary Tree from Preorder and Inorder Traversal</a></li> <li><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/" rel="external nofollow noopener" target="_blank">Construct Binary Tree from Inorder and Postorder Traversal</a></li> <li><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/" rel="external nofollow noopener" target="_blank">Flatten Binary Tree to Linked List</a></li> <li><a href="https://leetcode.com/problems/construct-string-from-binary-tree/description/" rel="external nofollow noopener" target="_blank">Construct String from Binary Tree</a></li> <li><a href="https://leetcode.com/problems/maximum-binary-tree/description/" rel="external nofollow noopener" target="_blank">Maximum Binary Tree</a></li> <li><a href="https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/description/" rel="external nofollow noopener" target="_blank">Recover a Tree from Preorder Traversal</a></li> <li><a href="https://leetcode.com/problems/all-possible-full-binary-trees/description/" rel="external nofollow noopener" target="_blank">All Possible Full Binary Trees</a></li> </ul> <p><strong>Code Example (Construct Binary Tree from Preorder and Inorder Traversal):</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Construct Binary Tree from Preorder and Inorder Traversal in C++</span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
</span>
<span class="n">TreeNode</span><span class="o">*</span> <span class="nf">buildTreeHelper</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">preorder</span><span class="p">,</span> <span class="kt">int</span> <span class="n">preStart</span><span class="p">,</span> <span class="kt">int</span> <span class="n">preEnd</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">inorder</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inStart</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inEnd</span><span class="p">,</span>
                          <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">inorderMap</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">preStart</span> <span class="o">&gt;</span> <span class="n">preEnd</span> <span class="o">||</span> <span class="n">inStart</span> <span class="o">&gt;</span> <span class="n">inEnd</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">rootVal</span> <span class="o">=</span> <span class="n">preorder</span><span class="p">[</span><span class="n">preStart</span><span class="p">];</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">TreeNode</span><span class="p">(</span><span class="n">rootVal</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">rootIndex</span> <span class="o">=</span> <span class="n">inorderMap</span><span class="p">[</span><span class="n">rootVal</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">leftTreeSize</span> <span class="o">=</span> <span class="n">rootIndex</span> <span class="o">-</span> <span class="n">inStart</span><span class="p">;</span>

    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">buildTreeHelper</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">preStart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">preStart</span> <span class="o">+</span> <span class="n">leftTreeSize</span><span class="p">,</span>
                                 <span class="n">inorder</span><span class="p">,</span> <span class="n">inStart</span><span class="p">,</span> <span class="n">rootIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inorderMap</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">buildTreeHelper</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">preStart</span> <span class="o">+</span> <span class="n">leftTreeSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">preEnd</span><span class="p">,</span>
                                  <span class="n">inorder</span><span class="p">,</span> <span class="n">rootIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inEnd</span><span class="p">,</span> <span class="n">inorderMap</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TreeNode</span><span class="o">*</span> <span class="nf">buildTree</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">preorder</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">inorder</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">inorderMap</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inorder</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">inorderMap</span><span class="p">[</span><span class="n">inorder</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">buildTreeHelper</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">preorder</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                           <span class="n">inorder</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">inorder</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inorderMap</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div> <h3 id="explanation-5">Explanation</h3> <p>•Mapping Inorder Indices: A hash map is used to store the indices of values in the inorder traversal, allowing for quick lookups when dividing the tree into left and right subtrees. •Recursive Construction: The tree is constructed recursively by determining the root node from the preorder traversal and dividing the inorder traversal into left and right subtrees. •Handling Subtrees: The left and right subtrees are recursively constructed using the corresponding segments of the preorder and inorder traversals.</p> <h3 id="applications-1">Applications</h3> <p>•Tree Reconstruction: Building a binary tree from traversal data, which is common in parsing tasks, compilers, and data reconstruction. •Tree Transformation: Converting trees into different forms, such as linked lists, strings, or arrays, for use in various algorithms and data processing tasks.</p> <h2 id="pattern-8-advanced-binary-tree-problems">Pattern 8: Advanced Binary Tree Problems</h2> <p><strong>Overview:</strong> Advanced binary tree problems often combine multiple concepts and require deep insights into the structure and properties of binary trees. These problems may involve complex operations such as finding the maximum path sum, serializing and deserializing trees, or placing binary tree cameras to monitor nodes. They typically require a mix of traversal techniques, dynamic programming, and advanced recursion.</p> <p><strong>Key Points:</strong></p> <ul> <li> <strong>Maximum Path Sum:</strong> Finding the path in a binary tree where the sum of node values is the highest. This path may start and end at any node.</li> <li> <strong>Serialization and Deserialization:</strong> Converting a binary tree into a format that can be stored or transmitted and then reconstructing the tree from that format.</li> <li> <strong>Binary Tree Cameras:</strong> Placing cameras in the tree to monitor all nodes with the fewest number of cameras, usually involves dynamic programming or greedy approaches.</li> <li> <strong>Combination of Concepts:</strong> Problems in this category often require combining basic tree operations with more advanced techniques like dynamic programming, backtracking, or even graph algorithms.</li> </ul> <p><strong>Problems:</strong></p> <ul> <li><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/description/" rel="external nofollow noopener" target="_blank">Binary Tree Maximum Path Sum</a></li> <li><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/" rel="external nofollow noopener" target="_blank">Serialize and Deserialize Binary Tree</a></li> <li><a href="https://leetcode.com/problems/binary-tree-cameras/" rel="external nofollow noopener" target="_blank">Binary Tree Cameras</a></li> <li><a href="https://leetcode.com/problems/recover-binary-search-tree/" rel="external nofollow noopener" target="_blank">Recover Binary Search Tree</a></li> </ul> <p><strong>Code Example (Binary Tree Maximum Path Sum):</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Binary Tree Maximum Path Sum in C++</span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">maxPathSumHelper</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">maxSum</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="kt">int</span> <span class="n">leftGain</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">maxPathSumHelper</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">maxSum</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">rightGain</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">maxPathSumHelper</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">maxSum</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    
    <span class="kt">int</span> <span class="n">priceNewPath</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="n">leftGain</span> <span class="o">+</span> <span class="n">rightGain</span><span class="p">;</span>
    
    <span class="n">maxSum</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">maxSum</span><span class="p">,</span> <span class="n">priceNewPath</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">leftGain</span><span class="p">,</span> <span class="n">rightGain</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">maxPathSum</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>
    <span class="n">maxPathSumHelper</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">maxSum</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">maxSum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="explanation-6">Explanation</h3> <p>•Recursive Helper Function: The helper function calculates the maximum gain from the left and right subtrees. It ensures that if a subtree’s gain is negative, it is discarded (i.e., treated as 0). •Calculating the Path Sum: The path sum for the current node is calculated by adding the node’s value to the maximum gains from the left and right subtrees. •Updating the Maximum Sum: The global maximum path sum is updated if the current path sum is higher than the previously recorded maximum. •Return Value: The function returns the maximum gain that can be obtained by continuing the path through either the left or right subtree.</p> <h3 id="applications-2">Applications</h3> <p>•Optimal Substructure Problems: Advanced binary tree problems often require finding optimal substructures, such as the maximum path sum that can be formed by combining multiple subtrees. •Data Compression and Transmission: Serialization and deserialization are key in transmitting tree data over networks or storing it in a compressed format. •Security and Monitoring: Placing cameras or other monitoring devices efficiently in hierarchical structures, ensuring minimal coverage overlaps.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="https://blog.google/technology/ai/google-gemini-update-flash-ai-assistant-io-2024/" target="_blank" rel="external nofollow noopener">Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra</a> <svg width="1rem" height="1rem" viewbox="0 0 30 30" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="https://medium.com/@al-folio/displaying-external-posts-on-your-al-folio-blog-b60a1d241a0a?source=rss-17feae71c3c4------2" target="_blank" rel="external nofollow noopener">Displaying External Posts on Your al-folio Blog</a> <svg width="1rem" height="1rem" viewbox="0 0 30 30" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/nlp-interview-guide/">NLP Interview Guide - Key Concepts and Techniques</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/knapsack-like/">Mastering Knapsack The Dynamic Programming Patterns You Need to Know</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/graphs/">Graph Algorithms Deep Dive Key Concepts and Techniques</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Rahul Saxena. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>